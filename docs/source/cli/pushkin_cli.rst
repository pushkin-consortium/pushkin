.. _pushkin_cli:

Pushkin CLI
################
The Pushkin command-line package is available via NPM. We highly recommend a global install in order to make working with Pushkin projects as easy as possible:

.. code-block:: bash
	
	$ npm install -g pushkin-cli

Any subcommand that affects a specific project must be run from a folder inside the project you wish to modify.

The CLI has the following subcommands:

.. _`pushkin site`:
site
=============
Syntax: ``pushkin site``

Options: ``list``
-----------------
Syntax: ``pushkin site list``.

Returns a list of available site templates. 

Options: ``[template]``
-----------------
Syntax: ``pushkin site default``.

Downloads template site of type ``template`` into the current working directory. The example above retrieves the "default" template.

experiment
==============
Syntax: ``pushkin experiment``

Options: ``list``
-----------------
Syntax: ``pushkin experiment list``.

Returns a list of available experiment templates. 

Options: ``[template]``
-----------------
Syntax: ``pushkin experiment basic``.

Downloads experiment templateof type ``template`` into the ``experiments`` folder of your project. The example above retrieves the "default" template.

setupdb
----------------
Syntax: ``pushkin setupdb``

Runs migrations and seeds for experiments. Ensures experiments using the same database (as defined in ``pushkin.yaml``) are migrated at the same time to avoid errors with the knex_migrations table.

.. _prep:
prep
=======================
Syntax: ``pushkin prep``

Run inside a Pushkin project to prepare Pushkin to be run. Packages generated by calling ``npm pack`` inside each experiment's web page and api controllers directories are moved to the core Pushkin code, installed there, and linked to the core code. Previous modules are uninstalled and removed.

Details
-----------
The code for ``prep`` is a bit convoluted (sorry). It loops through each experiment in the experiments folder (as defined by ``pushkin.yaml``). For each experiment, it does thie following:

- It compiles and then tarballs the api controllers. These are moved to ``pushkin/api/tempPackages``. This package is then added as a local package to ``pushkin/api/package.json``, which allows them to be called during production.

- It compiles the worker and then builds a docker image for it. It is then added to ``docker-compose.dev.yml`` so that docker knows to include it when the website is built. 

- It compiles and tarballs ``web page`` and moves it to ``pushkin/front-end/tempPackages``. This package is then added as a local package to ``pushkin/front-end/tempPackages``.

Finally, it updates ``pushkin/front-end/src/experiments.js`` to list each experiment, along with key information from the experiment's config file. This will be read by the front end to build the list of experiments to display to potential participants.  

Note that before any of this happens, ``prep`` actually goes through and deletes all old tempPackages, cleans up the package.jsons and docker-compose-dev.yml and empties experiments.js. Thus, to delete an experiment, all you have to do is delete it's folder from the experiment folder. (Of course, that won't get rid of the docker image for the worker, so you'll need to clean those up by hand periodically.)

dev
=======================
Syntax: ``pushkin dev``

Start the development server. This just runs ``docker-compose -f pushkin/docker-compose.dev.yml up --build --remove-orphans;``, saving you the trouble of remembering the syntax. Unfortunately, you also don't see any of the output from docker, so if there are errors, you won't know.
