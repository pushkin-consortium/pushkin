{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Warning</p> <p>Due to an update in AWS resources, the CLI-based AWS deploy does not currently work and is being updated. In the meantime, you can still manually deploy to AWS.</p> <p></p>"},{"location":"#pushkin-provides-a-customizable-scalable-ecosystem-for-massive-online-psychological-experiments","title":"Pushkin provides a customizable, scalable ecosystem for massive online psychological experiments.","text":"<p>The goal of the Pushkin project is to help researchers efficiently create and maintain an online laboratory. These websites typically take \u2014 and Pushkin primarily supports \u2014 a citizen-science approach to participant recruitment, in which strategies such as gamification and virality motivate participation. As such, Pushkin aims to include everything researchers need for their online labs, including (but not limited to) customizable website and experiment templates, streamlined site deployment, and database tools. With Pushkin, researchers can focus more on experiment design and less on the intricacies of modern web development.</p> <p>It's recommended for new users to start by installing Pushkin and its dependencies and completing the quickstart tutorial, in which they'll create a simple demo site. Since Pushkin uses jsPsych to build experiments, it's also recommended that users consult the jsPsych documentation if they are not previously familiar with this software. From there, users might want to consult the materials on Pushkin's site and experiment templates.</p> <p>If you'd like to ask a question, report a bug, or request a feature, GitHub Discussions is the place to start. To get the latest news and updates on Pushkin, sign up for our newsletter.</p> <p>Note</p> <p>You're viewing version 4.1 of the Pushkin documentation, which corresponds to version 4.1 of pushkin-cli, the primary software in the Pushkin ecosystem. Other Pushkin packages and templates are independently versioned, and any compatibility constraints with pushkin-cli are noted on their respective documentation pages.</p>"},{"location":"about/about-pushkin/","title":"About Pushkin","text":"<p>Pushkin is an open-source project created by Joshua Hartshorne. The goal of the Pushkin project is to help researchers efficiently create and maintain an online laboratory. These websites typically take \u2014 and Pushkin primarily supports \u2014 a citizen-science approach to participant recruitment, in which strategies such as gamification and virality motivate participation. As such, Pushkin aims to include everything researchers need for their online labs, including (but not limited to) customizable website and experiment templates, streamlined site deployment, and database tools. With Pushkin, researchers can focus more on experiment design and less on the intricacies of modern web development.</p>"},{"location":"about/about-pushkin/#citation","title":"Citation","text":"<p>Hartshorne, J. K., de Leeuw, J. R., Goodman, N. D., Jennings, M., &amp; O\u2019Donnell, T. J. (2019). A thousand studies for the price of one: Accelerating psychological science with Pushkin. Behavior research methods, 51, 1782-1803. doi:10.3758/s13428-018-1155-z</p>"},{"location":"about/about-pushkin/#funding","title":"Funding","text":"<p>This material is based upon work supported by the National Science Foundation under Grant No. 2229631 and 2318474.</p> <p>Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation.</p>"},{"location":"about/pushkin-license/","title":"License","text":"<p>Pushkin is licensed under the MIT license:</p> <p>The MIT License (MIT)</p> <p>Copyright (c) 2015-2024 Joshua\u00a0Hartshorne</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"advanced/users-and-authentication/","title":"Users &amp; Authentication","text":"<p>Subject responses are associated with a username. This is either a randomly-generated string, or it\u2019s based off an auth0 userID. The value of the username is maintained in the redux store as <code>UserID</code>.</p> <p>The userID is set by a redux saga:</p> <pre><code>//actions/userInfo.js\n\nexport function getUser(isAuthenticated, user) {\n  return {\n    type: GET_USER,\n    isAuthenticated: isAuthenticated,\n    user: user\n  };\n}\n\n//sagas/userInfo.js\n\nexport function* getUserLogic(action) {\n  console.log('Saga2 initialized...');\n  const id = action.isAuthenticated ?\n    action.user :\n    yield session.get();\n  console.log(id);\n  yield put({ type: SET_USER_ID, id: id });\n}\n\nexport function* getUser() {\n  yield takeLatest(GET_USER, getUserLogic);\n}\n</code></pre> <p>Note that the action needs to be passed <code>isAuthenticated</code> and <code>user</code>, both of which come from the AuthProvidor (see below). For convenience, this saga is triggered every time the Header is loaded (which is on every page):</p> <pre><code>const Header = props =&gt; {\n  const { isAuthenticated, loginWithRedirect, logout, user } = useAuth0();\n  if (!CONFIG.useAuth) {\n    const isAuthenticated = false;\n    const user = null;\n  }\n\n  useEffect(() =&gt; {\n    props.dispatch(getUser(isAuthenticated, user));\n  }, [isAuthenticated, props.userID, user]);\n</code></pre> <p>Note that <code>userEffect</code> is a React lifecycle hook for functional components. It gets triggered when the component is loaded, as well as any time the values of <code>isAuthenticated, props.userID</code> or <code>user</code> change.</p> <p>In principle, this saga could be triggered elsewhere. One thing to keep track of is that because it is asynchronous, components (including the header) may load before the user has been set.</p>"},{"location":"advanced/users-and-authentication/#generating-userids","title":"Generating UserIDs","text":""},{"location":"advanced/users-and-authentication/#randomly-generated-string","title":"Randomly-generated string","text":"<p>If authenticated with auth0 is not enabled, then the value of <code>props.userID</code> comes from a cookie. For that code, see <code>front-end/src/utils/session.js</code>. The purpose of the cookie is to enable the userID to persist across browser refreshes (browser refresh re-initializes the Redux store.) Maximum life of the cookie is 2 days. (We aren\u2019t in the business of tracking people without opt-in consent.)</p> <p>Note that if authentication is not enabled, then the value of <code>isAuthenticated</code> will always be <code>false</code>. (See the variable definitions in the Header component.)</p> <p>Note that the action triggering the creation (or checking) of the cookie (<code>getSessionUser()</code>) is handled by a Redux Saga (see <code>front-end/src/sagas</code>).</p>"},{"location":"advanced/users-and-authentication/#auth0","title":"Auth0","text":"<p>If authentication is enabled, then userIDs can be supplied by auth0. We use code from the auth0 SPA quickstart, which is found in <code>front-end/src/utils/react-auth0-spa.js</code>. This code provides a component that wraps the entire application in <code>front-end/src/index.js</code>:</p> <pre><code>&lt;Auth0Provider\n  domain={CONFIG.authDomain}\n  client_id={CONFIG.authClientID}\n  redirect_uri={window.location.origin}\n  onRedirectCallback={onRedirectCallback}\n&gt;\n  &lt;Provider store={store}&gt;\n    &lt;Router history={customHistory}&gt;\n      &lt;App /&gt;\n    &lt;/Router&gt;\n  &lt;/Provider&gt;\n&lt;/Auth0Provider&gt;,\n</code></pre> <p>As you can see, it looks a lot like the Redux provider. It works similarly: children get access to a few useful variables and methods. You can see this in <code>react-auth0-spa.js</code>:</p> <pre><code>return (\n  &lt;Auth0Context.Provider\n    value={{\n      isAuthenticated,\n      user,\n      loading,\n      popupOpen,\n      loginWithPopup,\n      handleRedirectCallback,\n      getIdTokenClaims: (...p) =&gt; auth0Client.getIdTokenClaims(...p),\n      loginWithRedirect: (...p) =&gt; auth0Client.loginWithRedirect(...p),\n      getTokenSilently: (...p) =&gt; auth0Client.getTokenSilently(...p),\n      getTokenWithPopup: (...p) =&gt; auth0Client.getTokenWithPopup(...p),\n      logout: (...p) =&gt; auth0Client.logout(...p)\n    }}\n  &gt;\n    {children}\n  &lt;/Auth0Context.Provider&gt;\n);\n</code></pre> <p>You will notice <code>user</code>. By default, the value of <code>user</code> is the username from whatever social media application (etc.) the user used to authenticate. This is often the user\u2019s actual name, which we don\u2019t want. So the auth0 quickstart code was modified to retrieve the auth0 numerical ID instead, which is presumably (??) unique to your application. We then immediately run this through a salted hash.</p> <p>Why? It makes it harder to link data in a Pushkin database to a person. That is, someone who had access to your database and to your auth0 account still wouldn\u2019t be able to match the user data to an individual in auth0. They would also need the salt string, which is stored separately. Even if they had it, it would be a pain to use, because you can\u2019t easily decrypt something that has been hashed. The only option would be to encrypt every auth0 ID and then see what in the database matches.</p> <p>They key code is in <code>utils/react-auth0-spa.js</code>. First, we define a helper function:</p> <pre><code>var crypto = require('crypto');\nvar sha512 = function(id, salt){\n    var hash = crypto.createHmac('sha512', salt); /** Hashing algorithm sha512 */\n    hash.update(id);\n    var value = hash.digest('base64');\n    return value;\n};\n</code></pre> <p>There are several different places where userIDs are retrieved. In each case, we encrypt:</p> <pre><code>const claims = await auth0FromHook.getIdTokenClaims();\nconst encrypted = await sha512(claims.sub, CONFIG.salt);\nsetUser(encrypted);\n</code></pre> <p>Finally, note that when users log out of auth0, the <code>userID</code> is set to <code>null</code>:</p> <pre><code>&lt;b.Button onClick={() =&gt; {\n    logout();\n    props.dispatch(setUserID(null));\n    }\n  }&gt;Logout&lt;/b.Button&gt;\n</code></pre> <p>This will trigger the assignment of a new <code>userID</code> via the cookie method.</p>"},{"location":"advanced/users-and-authentication/#using-userids","title":"Using UserIDs","text":"<p><code>userID</code> is automatically available to any component that is connected to the Redux store. This unfortunately does not include the quizzes themselves. Instead, the TakeQuiz component passes the entire Redux store as a prop:</p> <pre><code>class TakeQuiz extends React.Component {\n  render() {\n    const { match } = this.props;\n    const QuizComponent = expObject[match.params.quizName];\n    return (\n      &lt;div&gt;\n        &lt;QuizComponent {...this.props} /&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n</code></pre> <p>(Note that TakeQuiz is a connected component, so its props include the entire Redux store.)</p> <p>Most of the methods for Pushkin-Client expect to be explicitly sent the userID. This can be done from within the QuizComponent. For example:</p> <pre><code>endExperiment() {\n  this.setState({ experimentComplete: true });\n  pushkin.endExperiment(this.props.userID);\n}\n</code></pre> <p>The exception is any Pushkin Client method that is called directly by jsPsych\u2019s <code>onFinish</code> function. This is because this function takes a single argument, which is trial data. Here is an example:</p> <pre><code>saveStimulusResponse(data) {\n  // Because we are saving data, it should be coming with a userID already\n  // Might make sense at some point to confirm this is what we expect\n  const postData = {\n    user_id: data.user_id,\n    data_string: data\n  };\n  return this.con.post('/stimulusResponse', postData);\n}\n</code></pre> <p>You will see that this expects <code>user_id</code> to be passed as part of the data. The easiest way to make this happen is to use jsPsych\u2019s handy data.addProperties method. Here is a code snippet from one of the template experiments:</p> <pre><code>async startExperiment() {\n  this.props.history.listen(jsPsych.endExperiment);\n\n  jsPsych.data.addProperties({user_id: this.props.userID}); //See https://www.jspsych.org/core_library/jspsych-data/#jspsychdataaddproperties\n</code></pre>"},{"location":"developers/contributions/","title":"Contributing to Pushkin","text":"<p>We encourage contributions of all kinds, including changes to the Pushkin CLI and its supporting packages, development of new site and experiment templates, and improvements to the documentation.</p> <p>The project is managed entirely through Pushkin's GitHub repository. There you can:</p> <ul> <li>Use discussions to propose ideas for development and seek feedback on potential contributions.</li> <li>Use issues to track actionable next steps for contributions, like a page in the documentation that needs to be fixed, a bug in the code, or a specific feature with a clear scope.</li> <li>Submit a pull request with updates to the code. Pull requests will be reviewed by one or more members of the core team.</li> </ul>"},{"location":"developers/contributions/#guidelines-for-contributing","title":"Guidelines for contributing","text":"<p>Security vulnerabilities</p> <p>If your potential contribution relates to a security vulnerability, please refer to our security policy for guidance on reporting it privately.</p>"},{"location":"developers/contributions/#contributing-to-the-codebase","title":"Contributing to the codebase","text":"<p>We welcome contributions of any scope. To facilitate a smooth integration into the main codebase, we generally require a few things:</p> <ul> <li> <p>Updated relevant documentation: Any pages in <code>/docs</code> affected by your contribution should be updated. If new pages are needed, please create them. For instance, if you're contributing a new experiment template, we would expect that you:</p> <ul> <li>Add a documentation page to <code>/docs/exp-templates</code> with the format <code>exp-&lt;my-exp-name&gt;.md</code>.</li> <li>Update the mkdocs configuration file so that your new page shows up in the site navigation bar.</li> <li>Update the list of available templates in the overview of experiment templates.</li> </ul> </li> <li> <p>Inclusion of a changeset: Pushkin uses changesets as part of our release workflow for all packages published to npm (i.e., anything in <code>/packages</code> or <code>/templates</code>). Please include a changeset in your pull request. This overview explains how to add one. The Pushkin team is happy to provide guidance on this, but some general points to keep in mind:</p> <ul> <li>Changesets handles bumping versions of the packages you change; don't manually increment the version number in <code>package.json</code>.</li> <li>If you change is small enough for a single commit, it's nice to include the changeset in the commit.</li> <li>If your changes are more substantial and merit multiple commits, add the changeset to whichever commit you like (one of the final ones is probably most sensible). You don't need to include a changeset with every commit.</li> <li>In less common cases, your pull request might merit multiple changesets. Example situations might be if you are making unrelated changes to separate packages or a mix of patches and new features.</li> </ul> </li> <li> <p>Code style and quality: Contributions should follow the established coding standards and practices of the project. This includes writing clean, readable, and well-documented code. Please ensure that new code passes all existing tests and, where applicable, add new tests to cover your updates.</p> </li> </ul>"},{"location":"developers/contributions/#contributing-to-the-documentation","title":"Contributing to the documentation","text":"<p>Contributions to documentation, whether small corrections or adding new tutorials, are highly valued. The source files for this site can be found in the <code>/docs</code> folder of the Pushkin GitHub repository. Consult our instructions for building the docs locally in order to preview your updates. Contributions which affect only the documentation do not require a changeset (cf. Contributing to the codebase).</p>"},{"location":"developers/contributions/#contribution-flowchart","title":"Contribution flowchart","text":"<p>The flowchart below should give potential contributors an idea of what to expect. Action items specific to contributors and Pushkin team members are called out specifically as below:</p> <pre><code>    flowchart LR\n        contributor(Contributor responsibilities)\n        pushkin-team(Pushkin team responsibilities)\n        contributor:::contributor ~~~~ pushkin-team:::pushkin-team\n        classDef contributor stroke:#009485,stroke-width:3px,stroke-opacity:1,fill:#009485,fill-opacity:0.25\n        classDef pushkin-team stroke:#e92063,stroke-width:3px,stroke-opacity:1,stroke-dasharray:5,fill:#e92063,fill-opacity:0.25</code></pre> <p>As you'll notice, contributors' responsibilities are limited to the development phase of the procedure, but the deployment phase is shown in the second tab for completeness and instructive purposes.</p> Phase I: DevelopmentPhase II: Deployment <pre><code>    flowchart TB\n        START{START}\n        changes(Contributor makes changes in development fork)\n        what_changed(Do changes affect anything published to npm?)\n        changeset_needed(Contributor adds changeset)\n        commit(Contributor commits changes)\n        more_changes(Does contributor want to make additional changes?)\n        pull_request(Contributor makes pull request on main)\n        review(Pushkin team reviews pull request)\n        review_changes(Are additional changes needed?)\n        update_pr(Contributor commits requested changes)\n        accept_pr(Pushkin team accepts pull request)\n\n        START:::terminal --&gt; changes:::contributor\n        changes --&gt; what_changed:::non-action\n        what_changed -- Yes --&gt; changeset_needed:::contributor\n        what_changed -- No --&gt; commit:::contributor\n        changeset_needed --&gt; commit\n        commit --&gt; more_changes:::non-action\n        more_changes -- Yes --&gt; changes:::contributor\n        more_changes -- No --&gt; pull_request:::contributor\n        pull_request --&gt; review:::pushkin-team\n        review --&gt; review_changes:::non-action\n        review_changes -- Yes --&gt; update_pr:::contributor\n        update_pr --&gt; review_changes\n        review_changes -- No --&gt; accept_pr:::pushkin-team\n\n        classDef terminal font-weight:bolder,fill:transparent\n        classDef non-action fill:transparent\n        classDef contributor stroke:#009485,stroke-width:3px,stroke-opacity:1,fill:#009485,fill-opacity:0.25\n        classDef pushkin-team stroke:#e92063,stroke-width:3px,stroke-opacity:1,stroke-dasharray:5,fill:#e92063,fill-opacity:0.25</code></pre> <pre><code>    flowchart TB\n        accept_pr(Pushkin team merges contributor's changes)\n        what_changed(Do changes affect anything published to npm?)\n        docs_affected(Do changes affect docs?)\n        changesets_action(\n            Changesets workflow is triggered;\n            changesets are digested into changelogs;\n            version numbers are incremented;\n            workflow makes another pull request on main\n        )\n        accept_pr2(Pushkin team merges changes again)\n        changesets_action2(\n            Changesets workflow is triggered again;\n            updated packages are published to npm\n        )\n        docs_deploy(Pushkin team publishes updated docs)\n        END{END}\n\n        accept_pr:::pushkin-team --&gt; what_changed:::non-action\n        what_changed -- Yes --&gt; changesets_action:::non-action\n        what_changed -- No --&gt; docs_affected:::non-action\n        changesets_action --&gt; accept_pr2:::pushkin-team\n        accept_pr2 --&gt; changesets_action2:::non-action\n        changesets_action2 --&gt; docs_affected\n        docs_affected -- Yes --&gt; docs_deploy:::pushkin-team\n        docs_affected -- No --&gt; END:::terminal\n        docs_deploy --&gt; END\n\n        classDef terminal font-weight:bolder,fill:transparent\n        classDef non-action fill:transparent\n        classDef contributor stroke:#009485,stroke-width:3px,stroke-opacity:1,fill:#009485,fill-opacity:0.25\n        classDef pushkin-team stroke:#e92063,stroke-width:3px,stroke-opacity:1,stroke-dasharray:5,fill:#e92063,fill-opacity:0.25</code></pre>"},{"location":"developers/contributions/#licensing-and-copyright","title":"Licensing and copyright","text":"<p>By contributing to Pushkin, you agree that your contributions will be licensed under the MIT License. This means that your contributions can be freely used, modified, and shared by others under the same terms. Please ensure you have the right to submit any work you contribute.</p>"},{"location":"developers/documentation/","title":"Pushkin's documentation","text":""},{"location":"developers/documentation/#overview","title":"Overview","text":"<p>Pushkin's documentation practices have been heavily influenced by jsPsych (thanks for the inspiration!). The docs use Material for MkDocs. You can find the documentation files in the <code>/docs</code> directory of the Pushkin GitHub repo.</p>"},{"location":"developers/documentation/#local-testing","title":"Local testing","text":"<p>Since the docs are written in Markdown, the simplest of changes (e.g., typos) may not require a local build for testing purposes; the Markdown preview in your IDE may be sufficient. However, for anything substantive, you'll want to build and view the site locally to test your changes. After making changes in your development branch/fork, follow the steps below to test the site.</p>"},{"location":"developers/documentation/#install-poetry","title":"Install Poetry","text":"<p>MkDocs requires Python, which we'll assume you already have. Poetry is a package manager for Python. Building the Pushkin documentation doesn't necessarily require Poetry, but it makes it easier to install the docs' dependencies and guarantees the consistency of the build across contributors.</p> <p>The easiest way to install Poetry is with pipx. If you need to install pipx, follow their installation instructions. Then, all you need to do is run:</p> <pre><code>pipx install poetry\n</code></pre> <p>For details, see Poetry's installation instructions.</p>"},{"location":"developers/documentation/#install-dependencies-and-build-the-docs","title":"Install dependencies and build the docs","text":"<p>In the root of the repo, run either:</p> <pre><code>yarn docs:deploy &lt;docs_version&gt; latest\n</code></pre> <p>or</p> <pre><code>poetry install --no-root\npoetry run mike deploy &lt;docs_version&gt; latest -u --alias-type=redirect\n</code></pre> <p>Note</p> <p>The former command is simply shorthand for the latter, but the former may not work if you haven't first run <code>yarn install</code> in the process of making your changes. This is not necessarily true if you're just fixing an issue in the docs themselves.</p> <p>For the most faithful representation of what the docs site would look like with your changes, you should substitute <code>&lt;docs_version&gt;</code> with the major/minor version number (i.e. X.X) of pushkin-cli; however, getting the version number right isn't particularly important if all you're doing is local testing. It will simply change whether you overwrite an existing version of the docs or create a new one in your local <code>gh-pages</code> branch. It will not affect the public deployment of the docs.</p> <p>Including the <code>latest</code> alias in your command is helpful, since the docs website defaults to the version tagged <code>latest</code>. This way, when you preview your edits, the version you deployed will pop right up when you visit <code>http://localhost:8000/</code> (see below).</p> <p>This command builds the docs and commits the new or updated version to your local <code>gh-pages</code> branch. Note that you will not be able to push any of these commits to remote unless you are a core Pushkin maintainer, as doing so would affect the public deployment of the docs site. Of course, you can still push your commits editing the source files to whatever development branch/fork you like before making a pull request.</p>"},{"location":"developers/documentation/#preview-the-docs","title":"Preview the docs","text":"<p>In the root of the repo, run either:</p> <pre><code>yarn docs:serve\n</code></pre> <p>or (1)</p> <ol> <li>As above, <code>yarn docs:serve</code> may require previously running <code>yarn install</code>.</li> </ol> <pre><code>poetry run mike serve\n</code></pre> <p>You should now be able to view the docs at <code>http://localhost:8000</code>.</p> <p>Tip</p> <p>Each time you build the docs, <code>mike</code> automatically commits to your local <code>gh-pages</code> branch. If you're doing local testing as you compose updates to the docs, you will be left with a bunch of junk commits that you might want to delete. To delete them, run:</p> <pre><code>git checkout gh-pages\ngit reset --hard origin/gh-pages\n</code></pre> <p>This will reset your local <code>gh-pages</code> branch to the remote state (i.e. whatever is currently deployed on the live site). Make certain you've checked out <code>gh-pages</code> before running the reset command, as you don't want to accidentally reset your actual development branch.</p>"},{"location":"developers/documentation/#public-deployment","title":"Public deployment","text":"<p>Warning</p> <p>Only core Pushkin maintainers have permissions to push to <code>gh-pages</code>.</p> <p>As mentioned above, building the docs locally will automatically commit to <code>gh-pages</code>. Pushing these commits will update the public site. Typically, these steps should be automated by the workflow defined in <code>/.github/workflows/publish-docs.yml</code>, which helps ensure that <code>gh-pages</code> isn't being updated with changes that haven't yet been merged into <code>main</code>; however, in some cases, it may be necessary to update <code>gh-pages</code> manually.</p>"},{"location":"developers/getting-started-on-development/","title":"Getting started on development","text":""},{"location":"developers/getting-started-on-development/#overview-of-technologies","title":"Overview of technologies","text":"<p>Below is a non-exhaustive list of technologies in the Pushkin stack. Depending on what you're trying to develop some of these may be absolutely essential or less important. In some cases, we suggest learning resources. If you find other resources that are particularly helpful, please make a pull request to update this page!</p>"},{"location":"developers/getting-started-on-development/#front-end","title":"Front-end","text":"<ul> <li>HTML: A basic building block of websites, most HTML in a Pushkin site lives in conjunction with React tags.</li> <li>CSS: How stylings for websites are often declared. Pushkin currently uses a combination of CSS and JS to set the stylings.</li> <li>React: A JavaScript library for building interactive user interfaces and single-page applications (SPAs). Pushkin creates your site as an SPA using React.<ul> <li>You\u2019ll want a reasonably thorough grounding in Javascript and React (especially important for working with site templates). We recommend the Codecademy.com Learn React course.</li> <li>For a gentle introduction to SPAs, read this tutorial, which also describes incorporating authentication with Auth0. Note that this tutorial is slightly out of date in that Auth0 now uses auth0-spa-js for SPAs, and create-react-app suggests using function components rather than class components.</li> </ul> </li> <li>React-Router: Handles navigation components for setting your page URLs in your SPA.<ul> <li>To work with site templates, you probably want to learn more about routing using React-Router. We use v5, which is nearly identical to v4. If you read up on React Router, you\u2019ll see a lot of discussion of dynamic routing, though you can probably safely ignore this. One of the better tutorials available is here, though it\u2019s a bit short.</li> </ul> </li> <li>Redux: Redux is used to keep track of application-level state variables. In the case of Pushkin, we use React-Redux. A primary use case is keeping track of subject IDs.<ul> <li>The best tutorial we\u2019ve found for React-Redux is the official one. Note that it\u2019s a little out-of-date with regards to the use of object spread syntax (which is now supported by Node) and with how to handle asynchronous requests, for which we use redux sagas. A good place to start on why redux sagas are worth using is here.</li> </ul> </li> <li>jsPsych: jsPsych creates the experiments themselves within the Pushkin site and collects participants' data.<ul> <li>A solid grasp of jsPsych is essential for developing experiment templates. We recommend consulting their documentation.</li> </ul> </li> <li>Bootstrap: A framework for building responsive websites that adapt across devices. This includes features like navigation bars and buttons that easily adapt to different window dimensions. In the case of Pushkin, we use React-Bootstrap, which integrates Bootstrap styling into the React SPA.</li> <li>Aphrodite: Adds JavaScript-based styling (to update CSS) for React components. Currently, this is used to customize hover styling for the QuizTile icons and buttons but can be imported into other components to add more control over the styling via JavaScript.</li> </ul>"},{"location":"developers/getting-started-on-development/#back-end-and-database","title":"Back-end and database","text":"<ul> <li>Node: The language of the back end. This is used to set up the APIs, set up the server for the site, and more.<ul> <li>You\u2019ll need a decent understanding of Javascript and Node for doing development on the Pushkin CLI.</li> </ul> </li> <li>SQL: Used to manage the site databases, such as user information and experiment data. Pushkin is designed to use PostgreSQL.</li> <li>Knex: A SQL query builder for building, updating, and interacting with Pushkin databases.</li> <li>RabbitMQ: A message broker for validation and routing. Routes messages from the API controller for the worker to receive.</li> </ul>"},{"location":"developers/getting-started-on-development/#other","title":"Other","text":"<ul> <li>Docker: A platform for developing, shipping, and running applications. Used for testing your Pushkin site locally and deploying it.<ul> <li>There are a number of tutorials out there on Docker. For ongoing use, this cheatsheet is pretty useful.</li> </ul> </li> <li>Babel: Compiles the JavaScript used in the Pushkin project to ensure browser compatibility. This means having the ability to use modern JavaScript without losing accessibility for visitors on older browsers.</li> <li>Auth0: The service used for authorization to enable logins for site visitors.</li> <li>Jest: A JavaScript testing framework. The Pushkin team uses Jest in development of Pushkin packages and templates, but users can also add it to their Pushkin sites and develop their own tests.</li> </ul>"},{"location":"developers/getting-started-on-development/#testing-development-versions-of-pushkin-packages-and-templates","title":"Testing development versions of Pushkin packages and templates","text":"<p>All development tasks are going to start by cloning the <code>pushkin</code> repo and running <code>yarn install</code> from the root. The repo uses Yarn workspaces, so <code>yarn install</code> will install the dependencies for all Pushkin packages and templates. At this point, you can run either:</p> <pre><code>yarn workspaces run build\n# Execute build scripts for all packages and templates\n</code></pre> <p>or</p> <pre><code>yarn workspace &lt;package-name&gt; build\n# Build only the particular workspace you're testing\n# (equivalent to `yarn build` from the package root)\n</code></pre>"},{"location":"developers/getting-started-on-development/#site-and-experiment-templates","title":"Site and experiment templates","text":"<p>Site and experiment templates are the easiest Pushkin components to test, since the CLI includes an option to install templates from a local path. Simply follow the CLI's instructions and provide the local path to your development template. Before you test your updates, make sure you run the template's <code>build</code> script so <code>build/template.zip</code> will reflect your changes. You can do this by running <code>yarn workspace &lt;name-of-template&gt; build</code> from the root of the <code>pushkin</code> repo (or just <code>yarn build</code> from the root of the template itself).</p>"},{"location":"developers/getting-started-on-development/#pushkin-cli","title":"pushkin-cli","text":"<p>Building <code>pushkin-cli</code> will create a <code>/build</code> directory in your local copy of the package. You can call development versions of all the normal <code>pushkin</code> commands by calling <code>node</code> on <code>/build/index.js</code> and specifying which command you want. For example:</p> <pre><code>node &lt;path-to-repo&gt;/pushkin/packages/pushkin-cli/build/index.js install site\n</code></pre> <p>For ease, you might want to create your test site directory in same parent directory where you cloned the repo, so you can specify the path to the main build file like so:</p> <pre><code>node ../pushkin/packages/pushkin-cli/build/index.js prep\n</code></pre> <p>Don't forget to run <code>yarn workspace pushkin-cli build</code> prior to testing changes in order to update the build files. Note that you should run this command in the root of the <code>pushkin</code> repo, not your test site.</p>"},{"location":"developers/getting-started-on-development/#using-yalc-with-pushkin-utility-packages","title":"Using yalc with Pushkin utility packages","text":"<p>Testing development versions of the Pushkin utility packages (<code>pushkin-api</code>, <code>pushkin-client</code>, and <code>pushkin-worker</code>) is not as straightforward as with templates or the CLI. These packages typically get installed in various locations in the user's site via npm (through commands executed by the CLI). Normally, that means you can only include published versions. We can get around this using <code>yalc</code>, which you've already installed if you followed the Pushkin installation instructions.</p>"},{"location":"developers/getting-started-on-development/#pushkin-api","title":"pushkin-api","text":"<p>Assuming you already have a Pushkin site installed with at least one experiment in it, do the following:</p> <ol> <li>In your local copy of the <code>pushkin</code> repo (where presumably you have made changes to <code>pushkin-api</code>), go to <code>/packages/pushkin-api</code>. Be sure you've rebuilt the package to reflect your changes by running <code>yarn build</code>.</li> <li>Run <code>yalc publish</code> to create a locally published version of <code>pushkin-api</code>.</li> <li>Go to the <code>/pushkin/api</code> directory of your Pushkin site.</li> <li>Run <code>yalc add pushkin-api</code> to add your locally published version as a dependency.</li> <li>Go to the <code>/experiments/&lt;experiment-name&gt;/api controllers</code> directory of your Pushkin site.</li> <li>Again run <code>yalc add pushkin-api</code>.</li> <li>Open <code>package.json</code> in that same directory.</li> <li>You should see it has a property <code>\"files\"</code> with a value <code>[\"build/*\"]</code>. Add <code>\".yalc\"</code> to the list of files like such:</li> </ol> <pre><code>    \"files\": [\n        \"build/*\",\n        \".yalc\"\n    ],\n</code></pre> <ol> <li>Repeat steps 5-8 for each additional experiment in your site's <code>/experiments</code> directory.</li> </ol> <p>Now you should be able to run <code>pushkin prep</code> and <code>pushkin start</code>. If you make subsequent changes to <code>pushkin-api</code>, you'll need to:</p> <ol> <li>Re-run <code>yarn build</code> in <code>pushkin/packages/pushkin-api</code>.</li> <li>In the same directory, run <code>yalc push</code>. <code>yalc push</code> will update your locally published version of <code>pushkin-api</code> and push the changes wherever the package is being used. This saves you the hassle of running <code>yalc update</code> in all the places you previously ran <code>yalc add</code>.</li> </ol>"},{"location":"developers/getting-started-on-development/#pushkin-client","title":"pushkin-client","text":"<p>Assuming you already have a Pushkin site installed with at least one experiment in it, do the following:</p> <ol> <li>In your local copy of the <code>pushkin</code> repo (where presumably you have made changes to <code>pushkin-client</code>), go to <code>/packages/pushkin-client</code>. Be sure you've rebuilt the package to reflect your changes by running <code>yarn build</code>.</li> <li>Run <code>yalc publish</code> to create a locally published version of <code>pushkin-client</code>.</li> <li>Go to the <code>/pushkin/front-end</code> directory of your Pushkin site.</li> <li>Run <code>yalc add pushkin-client</code> to add your locally published version as a dependency.</li> <li>Go to the <code>/experiments/&lt;experiment-name&gt;/web page</code> directory of your Pushkin site.</li> <li>Again run <code>yalc add pushkin-client</code>.</li> <li>Open <code>package.json</code> in that same directory.</li> <li>You should see it has a property <code>\"files\"</code> with a value <code>[\"build/*\"]</code>. Add <code>\".yalc\"</code> to the list of files like such:</li> </ol> <pre><code>    \"files\": [\n        \"build/*\",\n        \".yalc\"\n    ],\n</code></pre> <ol> <li>Repeat steps 5-8 for each additional experiment in your site's <code>/experiments</code> directory.</li> </ol> <p>Now you should be able to run <code>pushkin prep</code> and <code>pushkin start</code>. If you make subsequent changes to <code>pushkin-client</code>, you'll need to:</p> <ol> <li>Re-run <code>yarn build</code> in <code>pushkin/packages/pushkin-client</code>.</li> <li>In the same directory, run <code>yalc push</code>. <code>yalc push</code> will update your locally published version of <code>pushkin-client</code> and push the changes wherever the package is being used. This saves you the hassle of running <code>yalc update</code> in all the places you previously ran <code>yalc add</code>.</li> </ol>"},{"location":"developers/getting-started-on-development/#pushkin-worker","title":"pushkin-worker","text":"<p>Assuming you already have a Pushkin site installed with at least one experiment in it, do the following:</p> <ol> <li>In your local copy of the <code>pushkin</code> repo (where presumably you have made changes to <code>pushkin-worker</code>), go to <code>/packages/pushkin-worker</code>. Be sure you've rebuilt the package to reflect your changes by running <code>yarn build</code>.</li> <li>Run <code>yalc publish</code> to create a locally published version of <code>pushkin-worker</code>.</li> <li>Go to the <code>/experiments/&lt;experiment-name&gt;/worker</code> directory of your Pushkin site corresponding to the experiment for which you'd like to use the modified worker.</li> <li>Run <code>yalc add pushkin-worker</code> to add your locally published version as a dependency.</li> <li>Open <code>package.json</code> in that same directory and add the property <code>\"files\"</code> with a value <code>[\".yalc\"]</code> like such:</li> </ol> <pre><code>    \"files\": [\".yalc\"],\n</code></pre> <ol> <li>Open the <code>Dockerfile</code> in the same directory and edit it to copy yalc files:</li> </ol> <pre><code>COPY .yalc /usr/src/app/.yalc/\nCOPY ./yalc.lock /usr/src/app/\n</code></pre> <p>These lines need to come before <code>WORKDIR</code> is changed. So for example:</p> <pre><code>FROM node:20.2\nCOPY Dockerfile index.js package.json start.sh yarn.lock /usr/src/app/\nCOPY .yalc /usr/src/app/.yalc/\nCOPY ./yalc.lock /usr/src/app/\nWORKDIR /usr/src/app\nRUN yarn install --production\nRUN apt-get update &amp;&amp; apt-get install -qy netcat\nEXPOSE 8000\nCMD [\"bash\",\"start.sh\"]\n</code></pre> <p>Now you should be able to run <code>pushkin prep</code> and <code>pushkin start</code>. If you make subsequent changes to <code>pushkin-worker</code>, you'll need to:</p> <ol> <li>Re-run <code>yarn build</code> in <code>pushkin/packages/pushkin-worker</code>.</li> <li>In the same directory, run <code>yalc push</code>. <code>yalc push</code> will update your locally published version of <code>pushkin-worker</code> and push the changes wherever the package is being used. This saves you the hassle of running <code>yalc update</code> where you previously ran <code>yalc add</code>.</li> </ol>"},{"location":"developers/getting-started-on-development/#testing-with-jest","title":"Testing with Jest","text":"<p>The pushkin repo is set up to run tests using Jest, a popular JavaScript testing library. In addition to testing contributions to the Pushkin codebase, Jest is also configured for Pushkin users to run tests on their own Pushkin sites.</p>"},{"location":"developers/getting-started-on-development/#jest-for-pushkin-repo-development","title":"Jest for pushkin repo development","text":"<p>After cloning the <code>pushkin</code> repo and running <code>yarn install</code>, you can run tests for all Pushkin packages and templates by running:</p> <pre><code>yarn test\n</code></pre> <p>Alternatively, to run tests for just one particular package or template, run:</p> <pre><code>yarn workspace &lt;workspace-name&gt; test\n</code></pre> <p>Improving test coverage is a priority for Pushkin, so we will happily receive pull requests for additional tests. If you're contributing to some other aspect of the codebase, we ask that you try to add appropriate tests to cover your updates (see our guide to contributions for more).</p>"},{"location":"developers/getting-started-on-development/#jest-for-user-site-development","title":"Jest for user site development","text":"<p>Pushkin sites come pre-configured to run Jest tests. Currently, the only tests distributed to Pushkin users enter your site through experiment templates; however, you can expand testing for your Pushkin site as you see fit. If you develop more sophisticated testing for your site, we encourage you to consider how it could be contributed back to the project, so other users might benefit as well.</p> <p>After running <code>pushkin install exp</code>, run <code>yarn test</code> from the root of your site to run tests for any experiments you've installed. Note that some tests written for experiment templates may fail when you customize the experiment. </p>"},{"location":"exp-templates/exp-basic/","title":"@pushkin-templates/exp-basic","text":"<p>The basic experiment template contains a simple \"Hello, world!\" jsPsych timeline. Its primary uses are for demonstration purposes and to provide a starting point for fully custom experiments.</p> <p>If you are developing a custom experiment, we recommend doing as much work as possible on your jsPsych timeline as a plain jsPsych <code>experiment.html</code> (jsPsych v7+). For example, if you have a somewhat complex experimental flow containing looping or conditional timelines, it will be much faster to test these elements if you can simply reload the page in a web browser. Testing updates to Pushkin experiment can be time-consuming, since you need to repeat the local deploy cyle (<code>pushkin stop; pushkin prep; pushkin start</code>) each time you test new code.</p> <p>Once you have your <code>experiment.html</code> working as you want it, dropping the timeline into a Pushkin experiment template is fairly straightforward. This process can be done manually (as described in the simple experiment tutorial) or automated by importing a jsPsych experiment while installing the basic experiment template.</p>"},{"location":"exp-templates/exp-basic/#installing-the-exp-basic-template","title":"Installing the exp-basic template","text":"<p>In your Pushkin site directory, run:</p> <pre><code>pushkin i exp\n</code></pre> <p>Name the experiment and select the main Pushkin distribution. Select <code>@pushkin-templates/exp-basic</code> from the list of available templates and choose which version you want (the latest is typically recommended). At this point, you will be asked if you'd like to import a jsPsych experiment. Note this feature only exists for the basic template, as it will overwrite the <code>experiment.js</code> file that comes with the template. See the section below on importing a jsPsych experiment for details.</p>"},{"location":"exp-templates/exp-basic/#importing-a-jspsych-experiment","title":"Importing a jsPsych experiment","text":"<p>Selecting the basic template will give you the option to import an existing jsPsych experiment. This feature assumes a workflow where you first implement the basics of your experiment design as a standalone jsPsych experiment, which is faster to test, before turning it into a Pushkin experiment. This feature executes two tasks:</p> <ol> <li>Identifying which jsPsych plugins you're using</li> <li>Extracting the code which builds up the experiment's timeline</li> </ol> <p>In order for these tasks to be sucessful, keep the following in mind:</p>"},{"location":"exp-templates/exp-basic/#plugin-identification","title":"Plugin identification","text":"<ul> <li>Only jsPsych plugins available via npm can be added automatically (any package scoped under @jspsych, @jspsych-contrib, or @jspsych-timelines). Custom plugins can still be used in your experiment, but you'll need to add them manually, as described here.</li> <li>Your experiment.html must use CDN-hosted plugins or import the plugins from npm. Plugins which you've downloaded and are hosting yourself will not be added automatically. See jsPsych's documentation for details.</li> <li>If your experiment.html specifies a specific version of a plugin, <code>pushkin i exp</code> records the version number or tag in a comment after the import statement in <code>experiment.js</code>. This comment, if present, is later read by <code>pushkin prep</code> in order to add that particular version to your experiment. Before running <code>prep</code>, you may edit the version number in order to change the version in your experiment, but be careful not to change the format of the comment.</li> <li>If you you've forgetten to import a plugin in <code>experiment.html</code>, it won't be added to your Pushkin experiment. In this case, your <code>experiment.html</code> shouldn't be running properly anyway, so you should hopefully be aware of the problem before trying to import the experiment into Pushkin.</li> <li>Likewise, if you import an extraneous plugin that's not actually used in <code>experiment.html</code>, it will also be added to your Pushkin experiment.</li> </ul>"},{"location":"exp-templates/exp-basic/#timeline-extraction","title":"Timeline extraction","text":"<ul> <li>This feature works simply by looking for the argument you provide to <code>jsPsych.run()</code> and copying everything from where that variable is declared until before <code>jsPsych.run()</code> is called. Consequently, the argument of <code>jsPsych.run()</code> must be the name of an array of timeline objects, not the array itself.</li> <li>Likewise, whatever you name the argument of <code>jsPsych.run()</code>, it must be declared before any of its component timeline objects are created. This is fairly standard practice, as something like <code>const timeline = [];</code> is usually near the top of most jsPsych experiments.</li> <li>Your experiment's equivalent to <code>const timeline = [];</code> cannot come before initializing jsPsych (i.e. <code>const jsPsych = initJsPsych();</code>). You don't want to call <code>initJsPsych()</code> in a Pushkin <code>experiment.js</code> (rather, it's called in <code>index.js</code>).</li> <li>All specifications for your stimuli and timeline must be created inside your <code>experiment.html</code> between the two lines of the script mentioned above. If your stimuli or timeline rely on other files, you'll need to add them manually (this includes non-inline CSS styling).</li> </ul>"},{"location":"exp-templates/exp-grammaticality-judgment/","title":"@pushkin-templates/exp-grammaticality-judgment","text":"<p>The grammaticality-judgment template includes an experiment in which participants rate the acceptability of target sentences.</p>"},{"location":"exp-templates/exp-grammaticality-judgment/#installing-the-exp-grammaticality-judgment-template","title":"Installing the exp-grammaticality-judgment template","text":"<p>In your Pushkin site directory, run:</p> <pre><code>pushkin i exp\n</code></pre> <p>Name the experiment and select the main Pushkin distribution. Select <code>@pushkin-templates/exp-grammaticality-judgment</code> from the list of available templates and choose which version you want (the latest is typically recommended).</p>"},{"location":"exp-templates/exp-grammaticality-judgment/#config-options","title":"Config options","text":"<p>In the experiment's <code>/web page/src</code> direrectory, you'll find the config file <code>config.js</code> (note that this is different from the <code>config.yaml</code> file in the root of the experiment). Here you'll find some options which change the behavior of the experiment:</p> <ul> <li><code>fontColor</code>: the color for experiment text</li> <li><code>fontSize</code>: the size for experiment text</li> <li><code>fontFamily</code>: the font for experiment text (note that multiple backups are specified, in case specific fonts are not available for particular participants)</li> <li><code>correctiveFeedback</code>: when set to <code>true</code>, two-alternative forced choice questions will indicate if the participant's response was correct (in green font) or not (in red font). For the likert scale or slider, text indicating if the sentence was grammatical or ungrammatical will show. For all response types, when this is set to <code>false</code>, a fixation cross appears instead of corrective feedback</li> <li><code>responseType</code>: controls whether the response type is two-alternative forced choice (\"2afc\"), five-point likert scale (\"likert\"), or a slider from 0-100 (\"slider\")</li> </ul>"},{"location":"exp-templates/exp-grammaticality-judgment/#stimuli","title":"Stimuli","text":"sentence_grammatical sentence_ungrammatical This is a sentence. This a sentence. He went to the park last night. He went the park last night. The cow is jumping. The cow are jumping. Which friend did she meet with? Which friend she meet with did? <p>The stimuli for this experiment have two parameters:</p> <ul> <li><code>sentence_grammatical</code>: the grammatically correct version of the sentence</li> <li><code>sentence_ungrammatical</code>: the grammatically incorrect version of the sentence</li> </ul>"},{"location":"exp-templates/exp-grammaticality-judgment/#customizing-a-grammaticality-judgment-experiment","title":"Customizing a grammaticality-judgment experiment","text":""},{"location":"exp-templates/exp-grammaticality-judgment/#finding-experiment-files-to-modify","title":"Finding experiment files to modify","text":"<p>If you have installed an experiment using the grammaticality judgment experiment template and called it <code>gram</code>, you should have a directory called <code>gram</code> in your experiments folder. This directory should be structured like this:</p> <pre><code>gram\n\u251c\u2500\u2500 api controllers\n\u251c\u2500\u2500 config.yaml\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 migrations\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 web page\n\u2514\u2500\u2500 worker\n</code></pre> <p>In order to customize your simple grammaticality judgment experiment, you will need to access two files, <code>config.js</code> and <code>stim.js</code>. These files can be found in <code>web page/src/</code>, a directory that looks like this:</p> <pre><code>src\n\u251c\u2500\u2500 assets\n\u251c\u2500\u2500 config.js\n\u251c\u2500\u2500 consent.js\n\u251c\u2500\u2500 debrief.js\n\u251c\u2500\u2500 experiment.js\n\u251c\u2500\u2500 index.js\n\u2514\u2500\u2500 stim.js\n</code></pre>"},{"location":"exp-templates/exp-grammaticality-judgment/#modifying-configjs","title":"Modifying <code>config.js</code>","text":"<p>This file controls the aesthetics of your experiment, including font color, font size, and font family. If you wanted to set the font color to <code>green</code>, set the font size to <code>24px</code>, and set the font family to a monospace font such as Courier New, you would modify <code>config.js</code> as follows:</p> <pre><code>// Custom stylin'\n\nvar experimentConfig = {\n    fontColor: \"green\",\n    fontSize: \"24px\",\n    fontFamily: \"'Courier New', Courier, monospace\",\n    correctiveFeedback: true\n    responseType: \"2afc\"\n}\n\nexport default experimentConfig;\n</code></pre> <p>You'll notice that <code>'Courier New'</code> is not <code>fontFamily</code>'s only specification. This is because it's important to list backup fonts in case your preferred font can't be loaded. You can read more about this practice here and see other CSS font combination ideas here.</p> <p>You'll also notice that <code>correctiveFeedback</code> is set to <code>true</code>. You can change this to <code>false</code> so that participants don't receive any feedback. Once you make this change, your <code>config.js</code> should look like this:</p> <pre><code>// Custom stylin'\n\nvar experimentConfig = {\n    fontColor: \"green\",\n    fontSize: \"24px\",\n    fontFamily: \"'Courier New', Courier, monospace\",\n    correctiveFeedback: false\n    responseType: \"2afc\"\n}\n\nexport default experimentConfig;\n</code></pre> <p>By default, <code>responseType</code> is set to <code>2afc</code>. You can change this to <code>likert</code> or <code>slider</code> to change the response type to a 5-item likert scale or a slider from 0-100. If you wanted to use a likert scale, your final <code>config.js</code> should look like this:</p> <pre><code>// Custom stylin'\n\nvar experimentConfig = {\n    fontColor: \"green\",\n    fontSize: \"24px\",\n    fontFamily: \"'Courier New', Courier, monospace\",\n    correctiveFeedback: false\n    responseType: \"likert\"\n}\n\nexport default experimentConfig;\n</code></pre> <p>You can run <code>pushkin prep</code> and <code>pushkin start</code> to see your changes.</p>"},{"location":"exp-templates/exp-grammaticality-judgment/#modifying-stimjs","title":"Modifying <code>stim.js</code>","text":"<p>This file controls the stimuli presented to participants. It specifies the sentences for each trial and denotes which is grammatical (sentence_grammatical) and which is not (sentence_ungrammatical).</p> <p>Say you have created the following table of stimuli for your experiment:</p> sentence_grammatical sentence_ungrammatical This is an example. This an example. He went for a walk. He went a walk. The frogs are jumping. The frogs is jumping. Where did she go? Where she did go? <p>In order to be able to use these stimuli in the grammaticality judgment experiment, you must use a table-to-JSON converter such as this one to format it correctly for jsPsych. Once it has been converted, paste the JSON into the <code>stim.js</code> file so that the new object of stimuli is assigned to the <code>stimArray</code> variable.</p> <p>Run <code>pushkin prep</code> and <code>pushkin start</code> again, and your experiment should be ready to go!</p>"},{"location":"exp-templates/exp-lexical-decision/","title":"@pushkin-templates/exp-lexical-decision","text":"<p>The lexical-decision template includes an experiment in which participants must choose as quickly as possible whether two strings are true words of English.</p>"},{"location":"exp-templates/exp-lexical-decision/#installing-the-exp-lexical-decision-template","title":"Installing the exp-lexical-decision template","text":"<p>In your Pushkin site directory, run:</p> <pre><code>pushkin i exp\n</code></pre> <p>Name the experiment and select the main Pushkin distribution. Select <code>@pushkin-templates/exp-lexical-decision</code> from the list of available templates and choose which version you want (the latest is typically recommended).</p>"},{"location":"exp-templates/exp-lexical-decision/#config-options","title":"Config options","text":"<p>In the experiment's <code>/web page/src</code> direrectory, you'll find the config file <code>config.js</code> (note that this is different from the <code>config.yaml</code> file in the root of the experiment). Here you'll find some options which change the behavior of the experiment:</p> <ul> <li><code>fontColor</code>: the color for experiment text</li> <li><code>fontSize</code>: the size for experiment text</li> <li><code>fontFamily</code>: the font for experiment text (note that multiple backups are specified, in case specific fonts are not available for particular participants)</li> <li><code>correctiveFeedback</code>: when to <code>true</code>, the bounding box will change color based on the participant's response (green for correct, red for incorrect); when set to <code>false</code>, the box remains black</li> </ul>"},{"location":"exp-templates/exp-lexical-decision/#stimuli","title":"Stimuli","text":"word_1 word_2 both_words related SOCKS SHOE True True SLOW FAST True True QUEEN KING True True LEAF TREE True True SOCKS TREE True False SLOW SHOE True False QUEEN FAST True False LEAF KING True False AGAIN PLAW False False BOARD TRUDE False False LIBE HAIR False False MOCKET MEET False False FLAFF PLAW False False BALT TRUDE False False LIBE NUNE False False MOCKET FULLOW False False <p>The stimuli for this experiment have four parameters:</p> <ul> <li>word_1: the word displayed in the top of the fixation box</li> <li>word_2: the word displayed in the bottom of the fixation box</li> <li>both_words: if <code>true</code>, \"Y\" is the correct answer (both <code>word_1</code> and <code>word_2</code> are real words); if false, \"N\" is the correct answer (at least one of <code>word_1</code> and <code>word_2</code> is not a real word)</li> <li>related: if <code>true</code>, the words are semantically related to each other (e.g. \"leaf\" and \"tree\"). If <code>false</code>, the words are unrelated (e.g. sock and tree)</li> </ul>"},{"location":"exp-templates/exp-lexical-decision/#customizing-a-lexical-decision-experiment","title":"Customizing a lexical-decision experiment","text":""},{"location":"exp-templates/exp-lexical-decision/#finding-experiment-files-to-modify","title":"Finding experiment files to modify","text":"<p>If you have installed an experiment using the lexical decision experiment template and called it <code>lex</code>, you should have a directory called <code>lex</code> in your experiments folder. This directory should be structured like this:</p> <pre><code>lex\n\u251c\u2500\u2500 api controllers\n\u251c\u2500\u2500 config.yaml\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 migrations\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 web page\n\u2514\u2500\u2500 worker\n</code></pre> <p>In order to customize your simple lexical decision experiment, you will need to access two files, <code>config.js</code> and <code>stim.js</code>. These files can be found in <code>web page/src/</code>, a directory that looks like this:</p> <pre><code>src\n\u251c\u2500\u2500 assets\n\u251c\u2500\u2500 config.js\n\u251c\u2500\u2500 consent.js\n\u251c\u2500\u2500 debrief.js\n\u251c\u2500\u2500 experiment.js\n\u251c\u2500\u2500 index.js\n\u2514\u2500\u2500 stim.js\n</code></pre>"},{"location":"exp-templates/exp-lexical-decision/#modifying-configjs","title":"Modifying <code>config.js</code>","text":"<p>This file controls the aesthetics of your experiment, including font color, font size, and font family. If you wanted to set the font color to <code>red</code>, set the font size to <code>22px</code>, and set the font family to a monospace font such as Courier New, you would modify <code>config.js</code> as follows:</p> <pre><code>// Custom stylin'\n\nvar experimentConfig = {\n  fontColor: \"red\",\n  fontSize: \"22px\",\n  fontFamily: \"'Courier New', Courier, monospace\",\n  correctiveFeedback: true,\n};\n\nexport default experimentConfig;\n</code></pre> <p>You'll notice that <code>'Courier New'</code> is not <code>fontFamily</code>'s only specification. This is because it's important to list backup fonts in case your preferred font can't be loaded. You can read more about this practice here and see other CSS font combination ideas here. You'll also notice that <code>correctiveFeedback</code> is set to <code>true</code>. You can change this to <code>false</code> so that participants don't receive any feedback.</p> <p>After making any desired changes, run <code>pushkin prep</code> and <code>pushkin start</code> to see the updates.</p>"},{"location":"exp-templates/exp-lexical-decision/#modifying-stimjs","title":"Modifying <code>stim.js</code>","text":"<p>This file controls the stimuli presented to participants. It specifies (1) the two words presented on the screen (<code>word_1</code> and <code>word_2</code>), (2) whether both words are true words (<code>both_words</code>), and (3) whether the two words are related to each other (<code>related</code>).</p> <p>Say you have created the following table of stimuli for your experiment:</p> word_1 word_2 both_words related FLOWER PETAL True True BALL NET True True DOG LEASH True True COMB BRUSH True True BABY BEAN True False CAGE FERN True False DOG FLOUR True False GOAT SAND True False VASE VATE False False ARM ARL False False COAT COET False False HAIR HAIP False False HAME HAMA False False DAKE GRAKE False False CLEB CLED False False AFTY AFLY False False <p>In order to use these stimuli in the lexical-decision experiment, you must use a table-to-JSON converter such as this one to format it correctly for jsPsych. Once it has been converted, paste the JSON into the <code>stim.js</code> file so that the new object of stimuli is assigned to the <code>stimArray</code> variable.</p> <p>Run <code>pushkin prep</code> and <code>pushkin start</code> again, and your experiment should be ready to go!</p>"},{"location":"exp-templates/exp-self-paced-reading/","title":"@pushkin-templates/exp-self-paced-reading","text":"<p>The self-paced-reading template includes an experiment in which participants read sentences presented in word-by-word fashion.</p>"},{"location":"exp-templates/exp-self-paced-reading/#installing-the-exp-self-paced-reading-template","title":"Installing the exp-self-paced-reading template","text":"<p>In your Pushkin site directory, run:</p> <pre><code>pushkin i exp\n</code></pre> <p>Name the experiment and select the main Pushkin distribution. Select <code>@pushkin-templates/exp-self-paced-reading</code> from the list of available templates and choose which version you want (the latest is typically recommended).</p>"},{"location":"exp-templates/exp-self-paced-reading/#config-options","title":"Config options","text":"<p>In the experiment's <code>/web page/src</code> direrectory, you'll find the config file <code>config.js</code> (note that this is different from the <code>config.yaml</code> file in the root of the experiment). Here you'll find some options which change the behavior of the experiment:</p> <ul> <li><code>fontColor</code>: the color for experiment text (see note below for details)</li> <li><code>fontSize</code>: the size for experiment text (see note below for details)</li> <li><code>fontFamily</code>: the font for experiment text (note that multiple backups are specified, in case specific fonts are not available for particular participants; see note below for details)</li> <li><code>comprehension</code>: when <code>true</code>, each self-paced reading trial will be followed by a two-alternative forced-choice comprehension question; when <code>false</code>, the experiment goes right to the next self-paced reading trial</li> <li><code>correctiveFeedback</code>: if <code>true</code>, participants will get feedback after answering each comprehension question which indicates whether their response was correct or incorrect; if <code>false</code>, no feedback will follow the comprehension questions; note that this parameter has no effect if comprehension questions are not being displayed</li> </ul> <p>Note</p> <p>The <code>fontColor</code>, <code>fontSize</code>, and <code>fontFamily</code> config options do not apply to the actual self-paced-reading stimuli (i.e. the text rendered by the jsPsych self-paced-reading plugin). To alter the aesthetics of these sentences, modify the plugin's parameters in <code>experiment.js</code> (see the plugin's documentation for details)</p>"},{"location":"exp-templates/exp-self-paced-reading/#stimuli","title":"Stimuli","text":"sentence comprehension The horse raced past the barn fell. ['What fell?', 'The horse', 'The barn'] Sam saw the teacher with glasses on. ['Who did Sam see?', 'The teacher', 'The student'] They saw the wooden boxes in two. ['What are the boxes made of?', 'Wood', 'Metal'] The mysterious bark came from a tree native to New Zealand. ['Where did the bark come from?', 'A tree', 'A dog'] <p>The stimuli for this experiment have two parameters:</p> <ul> <li><code>sentence</code>: the sentence or text to be read</li> <li><code>comprehension</code>: an array containing the specifications for the comprehension questions; the first element is the question itself, the second is the correct answer, and the third is the incorrect answer. The correct and incorrect answers are randomly assigned to the 'F' and 'J' keys in <code>experiment.js</code>.</li> </ul>"},{"location":"exp-templates/exp-self-paced-reading/#customizing-a-self-paced-reading-experiment","title":"Customizing a self-paced-reading experiment","text":""},{"location":"exp-templates/exp-self-paced-reading/#finding-experiment-files-to-modify","title":"Finding experiment files to modify","text":"<p>If you have installed an experiment using the self-paced reading experiment template and called it <code>spr</code>, you should have a directory called <code>spr</code> in your experiments folder. This directory should be structured like this:</p> <pre><code>spr\n\u251c\u2500\u2500 api controllers\n\u251c\u2500\u2500 config.yaml\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 migrations\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 web page\n\u2514\u2500\u2500 worker\n</code></pre> <p>In order to customize your self-paced reading experiment, you will need to access two files, <code>config.js</code> and <code>stim.js</code>. These files can be found in <code>web page/src/</code>, a directory that looks like this:</p> <pre><code>src\n\u251c\u2500\u2500 assets\n\u251c\u2500\u2500 config.js\n\u251c\u2500\u2500 consent.js\n\u251c\u2500\u2500 debrief.js\n\u251c\u2500\u2500 experiment.js\n\u251c\u2500\u2500 index.js\n\u2514\u2500\u2500 stim.js\n</code></pre>"},{"location":"exp-templates/exp-self-paced-reading/#modifying-configjs","title":"Modifying <code>config.js</code>","text":"<p>This file controls the aesthetics of your experiment, including font color, font size, and font family. If you wanted to set the font color to <code>blue</code>, set the font size to <code>36px</code>, and set the font family to a serif font such as Palatino Linotype, you would modify <code>config.js</code> as follows:</p> <pre><code>const experimentConfig = {\n  fontColor: \"blue\",\n  fontSize: \"36px\",\n  fontFamily: \"'Palatino Linotype', Palatino, serif\",\n  comprehension: true,\n  correctiveFeedback: true, // Only relevant if comprehension is set to true\n};\n\nexport default experimentConfig;\n</code></pre> <p>You'll notice that <code>'Palatino Linotype'</code> is not <code>fontFamily</code>'s only specification. This is because it's important to list backup fonts in case your preferred font can't be loaded. You can read more about this practice here and see other CSS font combination ideas here.</p> <p>Note that any font-related changes you make to <code>config.js</code> will not affect the font in the actual self-paced reading trials. To modify that font (and other plugin parameters), you will need to edit the trial in <code>experiment.js</code>. See the plugin documentation for details.</p> <p>You can run <code>pushkin prep</code> and <code>pushkin start</code> to see your changes.</p>"},{"location":"exp-templates/exp-self-paced-reading/#modifying-stimjs","title":"Modifying <code>stim.js</code>","text":"<p>This file controls the self-paced reading sentences and comprehension questions (if relevant) presented to participants. Create a new table of sentences and comprehension questions for your experiment, with your comprehension questions in a three-element array (i.e. <code>['&lt;question&gt;', '&lt;correct answer&gt;', '&lt;incorrect answer&gt;']</code>). Then use a table-to-JSON converter such as this one to format it correctly for jsPsych and paste the array into the <code>stim.js</code> file.</p> <p>Run <code>pushkin prep</code> and <code>pushkin start</code> again, and your experiment should be ready to go!</p>"},{"location":"exp-templates/exp-templates-overview/","title":"Overview of experiment templates","text":"<p>Experiments are added to a Pushkin site via templates. Experiment templates are distributed as npm packages, which get added to the user's site as dependencies when they run <code>pushkin install experiment</code>. The template files are then unzipped into the corresponding experiment directory and subsequently manipulated by the CLI.</p>"},{"location":"exp-templates/exp-templates-overview/#currently-available-experiment-templates","title":"Currently available experiment templates","text":"<ul> <li>exp-basic: The basic template generates a simple \"Hello, world!\" experiment. Use this template if you want to create your own custom Pushkin experiment from scratch.</li> <li>exp-grammaticality-judgment: The grammaticality-judgment template includes an experiment in which participants rate the acceptability of target sentences.</li> <li>exp-lexical-decision: The lexical-decision template includes an experiment in which participants must choose as quickly as possible whether two strings are true words of English.</li> <li>exp-self-paced-reading: The self-paced-reading template includes an experiment in which participants read sentences presented in word-by-word fashion.</li> </ul>"},{"location":"exp-templates/exp-templates-overview/#how-to-install-an-experiment-template","title":"How to install an experiment template","text":"<p>In your Pushkin site directory, run:</p> <pre><code>pushkin install experiment\n</code></pre> <p>or</p> <pre><code>pushkin i exp\n</code></pre> <p>The other permutations <code>pushkin i experiment</code> and <code>pushkin install exp</code> will likewise work. Follow the CLI's prompts to select the template you want to install. In addition to templates from the main distribution, the CLI also offers you the ability to install templates from:</p> <ul> <li>path: This option allows you to install an experiment template from a local path. In this case, the template must still be implemented as a package and will automatically be locally published using <code>yalc</code>. Use this option if you are developing a new experiment template or testing a development version of an existing one.</li> <li>npm: The CLI can attempt to install an experiment template from an arbitrary npm package, although obviously this will fail if the package isn't properly set up as a Pushkin experiment template. This option might be appropriate for you if you need to distribute a template you've developed (perhaps as private package) but don't wish to add it to the main Pushkin distribution. Generally, however, we encourage contributions of new templates that might be useful to the the broader Pushkin community (see our contributor guidelines and below for specific notes on contributing experiment templates).</li> </ul>"},{"location":"exp-templates/exp-templates-overview/#customizing-experiments","title":"Customizing Experiments","text":""},{"location":"exp-templates/exp-templates-overview/#adding-additional-jspsych-plugins","title":"Adding additional jsPsych plugins","text":"<p>Warning</p> <p>As of v1.7 of <code>pushkin-client</code>, every jsPsych trial in a Pushkin experiment needs to have a <code>stimulus</code> parameter in its data object (see this issue). Many jsPsych plugins do this by default, but some do not. Consult jsPsych's plugin documentation for all plugins that you wish to use in your experiment and check that their data object includes a <code>stimulus</code> parameter. If it does not, you can insert one when you define the trial in <code>experiment.js</code>:</p> <pre><code>data: {stimulus: jsPsych.timelineVariable('&lt;something_from_my_stimuli&gt;')}, // something meaningful\n// or\ndata: {stimulus: ''}, // a placeholder\n</code></pre> <p>If your trial doesn't output a <code>stimulus</code> parameter, its data will not be sent to the Pushkin database. Future updates to the Pushkin Client may address this issue.</p> <p>The current experiment templates use only a few of jsPsych's available plugins. Of course, for many experiments, you may want to use additional jsPsych plugins. After installing an experiment template, import the additional plugins at the top of your <code>experiment.js</code> (found in the experiment's <code>/web page/src</code> directory) in the same way as the plugins already included in the template. For example, if your experiment also uses the <code>survey-text</code> and <code>html-button-response</code> plugins, you would add:</p> <pre><code>import jsPsychSurveyText from \"@jspsych/plugin-survey-text\";\nimport jsPsychHtmlButtonResponse from \"@jspsych/plugin-html-button-response\";\n</code></pre> <p>The next time you run <code>pushkin prep</code>, any additional jsPsych plugins you want to import will be automatically added as dependencies to your experiment's web page component (provided they are available via npm -- this does not apply to custom plugins). If, for some reason, you wish to add these dependencies yourself prior to running <code>prep</code>, navigate to the <code>web page</code> directory of the experiment using <code>cd</code> and run <code>yarn add</code> for each particular plugin:</p> <pre><code> cd 'experiments/&lt;experiment_name&gt;/web page'\n yarn add @jspsych/plugin-survey-text\n yarn add @jspsych/plugin-html-button-response\n</code></pre> <p>See Yarn's documentation for instructions regarding adding specific versions of a particular package.</p> <p>This same procedure will work with community-developed plugins available through npm via the jspsych-contrib repository. Just replace <code>@jspsych</code> with <code>@jspsych-contrib</code>. The self-paced-reading template uses a plugin from <code>jspsych-contrib</code>.</p>"},{"location":"exp-templates/exp-templates-overview/#adding-custom-jspsych-plugins","title":"Adding custom jsPsych plugins","text":"<p>The procedure above only works for jsPsych plugins available through npm. If your experiment makes use of a custom plugin, follow the steps below:</p> <ol> <li>Add the plugin file to the <code>web page/src</code> folder of the experiment</li> <li>Add the plugin towards the top of your experiment.js file like <code>import jsPsychMovingWindow from './jspsych-moving-window';</code></li> </ol>"},{"location":"exp-templates/exp-templates-overview/#adding-static-assets","title":"Adding static assets","text":"<p>The current experiment templates do not use any image, audio, or video stimuli. In order to reference static assets such as these in your jsPsych timeline, put them in the experiment's <code>web page/src/assets/timeline</code> folder. You can use whatever directory structure inside that folder you please, if, for instance, you want to keep audio files separate from images or divide assets from different experimental lists. When you run <code>pushkin prep</code>, the contents of the timeline assets folder will be copied to <code>pushkin/front-end/public/experiments/&lt;experiment_name&gt;</code>, where <code>&lt;experiment_name&gt;</code> is replaced with the same name as the folder within your site's experiments directory. The folder <code>pushkin/front-end/public</code> can be referenced at runtime using the environment variable <code>process.env.PUBLIC_URL</code>. Thus, when you refer to static assets in your jsPsych timeline, the reference should be as follows.</p> <p>Assume your experiment's <code>web page/src/assets/timeline</code> directory looks like this:</p> <pre><code>\u2514\u2500\u2500 timeline\n    \u251c\u2500\u2500 colors\n    \u2502   \u251c\u2500\u2500 blue.png\n    \u2502   \u2514\u2500\u2500 orange.png\n    \u251c\u2500\u2500 shapes\n    \u2502   \u251c\u2500\u2500 square.jpg\n    \u2502   \u2514\u2500\u2500 circle.jpg\n    \u251c\u2500\u2500 cat.mp4\n    \u2514\u2500\u2500 dog.mp4\n</code></pre> <p>Then references to these files in your experiment would look like:</p> <pre><code>var block_1_stimuli = [\n  { stimulus: process.env.PUBLIC_URL + \"/&lt;experiment_name&gt;/colors/blue.png\" },\n  { stimulus: process.env.PUBLIC_URL + \"/&lt;experiment_name&gt;/shapes/square.jpg\" },\n  { stimulus: process.env.PUBLIC_URL + \"/&lt;experiment_name&gt;/cat.mp4\" },\n];\n\nvar block_2_stimuli = [\n  { stimulus: process.env.PUBLIC_URL + \"/[experiment_name]/colors/orange.png\" },\n  { stimulus: process.env.PUBLIC_URL + \"/[experiment_name]/shapes/circle.jpg\" },\n  { stimulus: process.env.PUBLIC_URL + \"/[experiment_name]/dog.mp4\" },\n];\n</code></pre> <p>The other contents of <code>web page/src/assets</code> should be static assets that will be imported by React. The reason for this process of copying to the site's public folder is that jsPsych timelines are not compiled by React. By the time jsPsych runs, the files here are no longer accessible. While you could store timeline assets from the beginning in the site's public folder, keeping them in the experiment's timeline assets folder allows you to store all of a particular experiment's resources in the same place and avoids file name collisions across different experiments. Additionally, your experiment \u2014 along with all its multimedia stimuli \u2014 can now be distributed as a template.</p> <p>Note that <code>process.env.PUBLIC_URL</code> works for local development. Depending on how you deploy to the web, this environment variable may not be available.</p>"},{"location":"exp-templates/exp-templates-overview/#contributing-experiment-templates","title":"Contributing experiment templates","text":"<p>There is currently no way of automatically packaging up an existing custom experiment into a new experiment template. How complicated the process will be of turning your experiment into a template depends on how much customization you've done (presumably based on the basic template). If all you've done is edit <code>experiment.js</code> and add a few jsPsych plugins, it should be easy to make those same changes to the basic template itself; on the other hand, more complex customizations may present unexpected challenges for creation of a template. We encourage potential template contributors to reach out to the Pushkin team if they encounter any such issues.</p> <p>In general, we encourage you to follow to the contributor guidelines. Additionally, if you'd like to contribute a template, please consider how you can make it maximally general by parameterizing as many of your customizations as you can. Try to imagine what variations on your experiment would be relevant for other researchers and make it easy to implement those variations via changing configuration settings.</p>"},{"location":"exp-templates/exp-templates-overview/#experiment-component-structure","title":"Experiment Component Structure","text":"<p>From the perspective of the web server, a Pushkin experiment involves a number of distinct elements. There is the HTML/JavaScript for the stimulus display and response recording (i.e. the \u201cfront end\u201d); there is the database, where data are stored; there is the worker, which handles reading from and writing to the database (plus potentially many other behind-the-scenes tasks!). Finally, there is the API, which communicates between the front end and the worker.</p> <p>For convenience, all the code is kept in the experiments folder as defined in <code>pushkin.yaml</code>. The CLI command <code>prep</code> automagically redistributes this code where it needs to go.</p>"},{"location":"exp-templates/exp-templates-overview/#experiment-configyaml-files","title":"Experiment Config.yaml Files","text":"<p>The config.yaml file provides information to the rest of Pushkin about the experiment. Below is a sample of what one might look like (after being installed into your site).</p> <pre><code>experimentName: My Cool Experiment\nshortName: My_Cool_Experiment\napiControllers:\n  mountPath: My_Cool_Experiment\n  location: api controllers\n  name: mycontroller\nworker:\n  location: worker\n  service:\n    image: My_Cool_Experiment\n    links:\n      - message-queue\n      - test_db\n      - test_transaction_db\n    environment:\n      AMQP_ADDRESS: 'amqp://message-queue:5672'\n      DB_USER: postgres\n      DB_PASS: example\n      DB_URL: test_db\n      DB_NAME: test_db\nwebPage:\n  location: web page\nmigrations:\n  location: migrations\nseeds:\n  location: ''\ndatabase: localtestdb\nlogo: logo512.png\ntext: Enter your experiment description here.\ntagline: Be a citizen scientist! Try this quiz.\nduration: ''\n</code></pre> <p>Each of the above fields is explained in detail below.</p>"},{"location":"exp-templates/exp-templates-overview/#experimentname","title":"experimentName","text":"<p>The full name of your experiment. This is used as a display name on the website to users.</p>"},{"location":"exp-templates/exp-templates-overview/#shortname","title":"shortName","text":"<p>This is a short, more computer-friendly version of your experiment\u2019s name. It should be unique as it is used as the folder name in the experiments folder.</p>"},{"location":"exp-templates/exp-templates-overview/#apicontrollers","title":"apiControllers","text":"<p>Note that this is an array. As many API controllers can be used as needed.</p>"},{"location":"exp-templates/exp-templates-overview/#mountpath","title":"mountPath","text":"<p>URL this controller\u2019s endpoint will be available at. The full path is <code>/api/&lt;mountPath&gt;</code>.</p>"},{"location":"exp-templates/exp-templates-overview/#location","title":"location","text":"<p>Path relative to the config file where the CLI will look for this module.</p>"},{"location":"exp-templates/exp-templates-overview/#name","title":"name","text":"<p>Used in logs.</p>"},{"location":"exp-templates/exp-templates-overview/#worker","title":"worker","text":""},{"location":"exp-templates/exp-templates-overview/#location_1","title":"location","text":"<p>Path relative to the config file where the CLI will look for this module.</p>"},{"location":"exp-templates/exp-templates-overview/#service","title":"service","text":"<p>This section is appended to Pushkin\u2019s core Docker Compose file. Note that message-queue is a requirement. If you\u2019re not using the local test database, <code>test_db</code> is not necessary. Database connection credentials should be unique to every user. The defaults are shown here for the testing database.</p>"},{"location":"exp-templates/exp-templates-overview/#webpage","title":"webPage","text":""},{"location":"exp-templates/exp-templates-overview/#location_2","title":"location","text":"<p>Path relative to the config file where the CLI will look for this module.</p>"},{"location":"exp-templates/exp-templates-overview/#migrations","title":"migrations","text":""},{"location":"exp-templates/exp-templates-overview/#location_3","title":"location","text":"<p>Path relative to the config file where the CLI will look for these files.</p>"},{"location":"exp-templates/exp-templates-overview/#seeds","title":"seeds","text":""},{"location":"exp-templates/exp-templates-overview/#location_4","title":"location","text":"<p>Path relative to the config file the CLI will look for these files. If you aren\u2019t seeding a database table, set this to <code>''</code>. Otherwise, if the folder pointed to by <code>location</code> is empty, database setup will fail.</p>"},{"location":"exp-templates/exp-templates-overview/#database","title":"database","text":"<p>A reference to a key defined in the core Pushkin config file. Experiments can share databases. The CLI will use this database to migrate and seed experiment data files. It is not used as connection information for any of the modules running the experiment, since these may or may not be inside containers and cannot use the same connection details as the CLI.</p>"},{"location":"exp-templates/exp-templates-overview/#logo-text-tagline-duration-other","title":"logo, text, tagline, duration, other","text":"<p>You may find it useful to include information about your experiment here that can be used by <code>front-end</code> to describe the experiment to potential subjects. For instance, the default pushkin site template uses:</p> <ul> <li><code>logo</code>: Image to be used as the logo for the experiment. The logo images should be stored in <code>pushkin/front-end/src/assets/images/quiz</code>.</li> <li><code>text</code>: The experiment description to be displayed for users to determine what quiz to play.</li> <li><code>tagline</code>: This is the description that shows when a quiz is shared via social media/email.</li> <li><code>duration</code>: The average length of the experiment to give users an idea of the time commitment.</li> </ul>"},{"location":"exp-templates/exp-templates-overview/#worker-component-migrations-and-seeds","title":"Worker Component, Migrations, and Seeds","text":""},{"location":"exp-templates/exp-templates-overview/#experiment-worker-component","title":"Experiment Worker Component","text":"<p>Workers handle the most complex aspect of a Pushkin experiment and different types of experiments could need workers with very different functionalities. Pushkin provides a simple template to start with.</p> <p>The job of a worker is to receive messages via RabbitMQ that (usually) come from an API controller. It looks up the appropriate information in the database and returns it to the requester. Workers are also the component that is responsible for implementing machine learning, as having direct access to this data allows it to make live, dynamic decisions during an experiment like what stimuli to serve next or predictions about a subject\u2019s next answers.</p>"},{"location":"exp-templates/exp-templates-overview/#experiment-migrations","title":"Experiment Migrations","text":"<p>Pushkin uses knex to manage database tables. Files inside the migrations directory are migration files that describe how to set up and take down the tables needed for an experiment. The CLI handles the details of connecting to and executing the appropriate order of commands required to set up all experiments' tables. Once the table structure has been created, seeding is used to populate the database with experiment data, such as stimuli.</p> <p>When making a new experiment with new migrations, it is helpful to prefix the filenames with numbers in order to get the order right (you want tables that are going to be referenced by other tables to be created first, so giving them an alphabetically earlier filename is helpful).</p>"},{"location":"exp-templates/exp-templates-overview/#experiment-seeds","title":"Experiment Seeds","text":"<p>Pushkin uses knex to facilitate moving data into an experiment\u2019s tables in a database. Files inside the seeds directory are seed files containing the data to be moved and directions on where to put it. Each experiment\u2019s seed files should align with the structure defined in its migration files. The CLI handles the execution of these files.</p>"},{"location":"exp-templates/exp-templates-overview/#experiment-web-page-component","title":"Experiment Web Page Component","text":"<p>This houses the front-end component of an experiment. Each experiment's web page package (as defined in its <code>package.json</code> file) is locally published by the CLI and attached to the core website. Web page components are named using the experiment's <code>shortName</code> (defined in the experiment\u2019s <code>config.yaml</code> file), plus <code>_web</code>. Pushkin uses React for the front end. Experiment web pages are mounted as React components and given the full size of the window under the header and navigation bar.</p>"},{"location":"exp-templates/exp-templates-overview/#recommended-structure","title":"Recommended Structure","text":"<p>At a minimum, the <code>web page/src</code> folder needs to contain an <code>index.js</code> file that includes all your experiment code. Technically, you don't even have to use jsPsych to implement your experiment. However, we recommend building on top of an experiment template. The <code>src</code> folder in experiment templates contains both <code>index.js</code> and <code>experiment.js</code> files. <code>experiment.js</code>, contains a function <code>createTimeline()</code>, within which you construct a jsPsych timeline just as you would for a standard jsPsych experiment; <code>createTimeline()</code> is then exported to <code>index.js</code>. The core functionality of interest is here:</p> <pre><code>  async startExperiment() {\n    this.setState({ experimentStarted: true });\n\n    await pushkin.connect(this.props.api);\n    await pushkin.prepExperimentRun(this.props.userID);\n\n    const jsPsych = initJsPsych({\n      display_element: document.getElementById('jsPsychTarget'),\n      on_finish: this.endExperiment.bind(this),\n      on_data_update: (data) =&gt; pushkin.saveStimulusResponse(data),\n    });\n\n    jsPsych.data.addProperties({user_id: this.props.userID}); //See https://www.jspsych.org/core_library/jspsych-data/#jspsychdataaddproperties\n\n    const timeline = createTimeline(jsPsych);\n\n    jsPsych.run(timeline);\n\n    document.getElementById('jsPsychTarget').focus();\n    this.setState({ loading: false });\n  }\n\n  async endExperiment() {\n    document.getElementById(\"jsPsychTarget\").innerHTML = \"Processing...\";\n    await pushkin.tabulateAndPostResults(this.props.userID, expConfig.experimentName)\n    document.getElementById(\"jsPsychTarget\").innerHTML = \"Thank you for participating!\";\n  }\n</code></pre> <p>A line of code worth noting is <code>on_data_update: (data) =&gt; pushkin.saveStimulusResponse(data)</code>. This uses a helper function from <code>pushkin-client</code> to save data each time the jsPsych on_data_update callback is triggered (i.e. at the end of each trial). Saving data after each trial is generally good practice, as opposed to sending all the data at the end of the experiment. You could write this behavior into the timeline itself, but this helper function saves some typing.</p> <p>Finally, when the timeline finishes, <code>endExperiment()</code> will be called. In the current experiment templates, this simply adds a \"Thank you for participating\" message. Current templates besides the basic template include some simple feedback which is specified inside the jsPsych timeline; however, one might have reasons for integrating more complex feedback into <code>endExperiment()</code>.</p>"},{"location":"exp-templates/exp-templates-overview/#assets","title":"Assets","text":"<p>The <code>assets</code> folder primarily contains static assets that will be imported by React. It also contains a folder called <code>timeline</code>, which holds assets which are needed inside the jsPsych timeline (e.g. audiovisual stimuli). The contents of the timeline assets folder get copied to the site's <code>pushkin/front-end/public/experiments/[experiment_name]</code> folder during <code>pushkin prep</code> (see above). The reason this is necessary is that jsPsych timelines are not compiled by React, so the contents of the <code>assets</code> directory will not be accessible when jsPsych runs. However, create-react-app provides a nifty workaround: <code>process.env.PUBLIC_URL</code> will point to the folder <code>pushkin/front-end/public</code> during runtime.</p>"},{"location":"exp-templates/exp-templates-overview/#customizing-the-client","title":"Customizing the client","text":"<p>Note</p> <p>This section is a work in progress!</p> <p>If you need to extend the client with custom API calls, etc., you should extend the <code>defaultClient</code> class.</p>"},{"location":"getting-started/deploying-to-aws/","title":"Deploying to AWS","text":"<p>Deploy your basic Pushkin site and experiments to Amazon Web Services.</p> <p>Warning</p> <p>Due to an update in AWS resources, the CLI-based AWS deploy does not currently work and is being updated. In the meantime, you can still manually deploy to AWS.</p>"},{"location":"getting-started/deploying-to-aws/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure your have:</p> <ol> <li>Finished the Quickstart, including installing a Postgres manager. </li> <li>Created an Amazon Web Services account. (Note: This must be done approximately 24 hours in advance of when you would like to follow this tutorial.) </li> </ol>"},{"location":"getting-started/deploying-to-aws/#install-required-software","title":"Install Required Software","text":""},{"location":"getting-started/deploying-to-aws/#aws-cli","title":"AWS CLI","text":"<p>Install the AWS CLI. Install the version for your operating system, not the Docker image.</p> <p>Configuration steps will follow on the next page.</p>"},{"location":"getting-started/deploying-to-aws/#ecs-cli","title":"ECS CLI","text":"<p>Install ECS CLI. (Do only the first page. There's no need follow the steps on the 'configuration' page. The Pushkin CLI will handle this for you.)</p> <p>Note that the ECS CLI is no longer being actively maintained, so we may probably migrate in the near future.</p>"},{"location":"getting-started/deploying-to-aws/#configure-the-aws-cli-and-ecs-clis","title":"Configure the AWS CLI and ECS CLIs","text":""},{"location":"getting-started/deploying-to-aws/#aws-cli_1","title":"AWS CLI","text":"<p>Configure the AWS CLI. (The main steps are reproduced below for your convenience.)</p> <p>First, you will need to generate access keys. Best practices dictate that you create an IAM Admin User and Group rather than creating root access keys. </p> <p>To create an IAM user, sign into Identity and Access Management in your AWS console using your root user credentials.</p> <p></p> <p>Navigate to My Account and enable access to billing data for IAM users.</p> <p></p> <p>Navigate back to Identity and Access Management, select Users in the left sidebar and click Add user. </p> <p></p> <p>Set username as <code>Administrator</code> and click Next: Permissions.</p> <p></p> <p>Under the Add user to group tab, select Create group. Call the group name <code>Administrators</code> and check the AdministratorAccess job function in the list of policies. Then click Create group to continue.</p> <p></p> <p>Click through the Tags page, review your settings and click Create user. Download the CSV with login information.</p> <p></p> <p>Return to the Users page and select the Security credentials tab for the <code>Administrator</code> user you just created. </p> <p></p> <p>Under Access keys, click Create access keys.</p> <p></p> <p>Run <code>aws configure --profile myprofile</code> (where you substitute <code>myprofile</code> with a name of your choosing; this is just in case you want to have multiple logins, which you probably will), pasting your Access Key ID and Secret Access key as needed.</p> <p>Note: When configuring AWS, be sure to specify <code>us-east-1</code> as your default region name and <code>json</code> as your default output format.</p> <p>The output should look like this.</p> <pre><code> aws configure\nAWS Access Key ID [None]: AKIAIOSFODNN7EXAMPLE\nAWS Secret Access Key [None]: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\nDefault region name [None]: us-east-1\nDefault output format [None]: json\n</code></pre> <p></p>"},{"location":"getting-started/deploying-to-aws/#ecs-cli_1","title":"ECS CLI","text":"<p>There's no need follow the steps on the ECS CLI 'configuration' page. The Pushkin CLI will handle this for you.</p> <p>Note: In configuring the ECS CLI, you'll need the AWS profile name you are using, as well as the related Access Key ID and Secret Access Key. If you can't remember the name of your profile, you can get a list of active profiles on your computer using:</p> <pre><code> aws configure list-profiles\n</code></pre> <p>To see the Access Key ID and Secret Access Key for a given profile, run the following, where <code>[profile]</code> is replaced with the name of the profile you want to use:</p> <pre><code> aws configure get aws_access_key_id --profile [profile]\n aws configure get aws_secret_access_key --profile [profile]\n</code></pre> <p></p>"},{"location":"getting-started/deploying-to-aws/#register-a-domain","title":"Register a domain","text":""},{"location":"getting-started/deploying-to-aws/#purchase-a-domain","title":"Purchase a domain","text":"<p>You can buy domains in many places, but there is some convenience to doing it through AWS itself, which is reasonably priced:</p> <p></p> <p>Cheaper domains on AWS currently cost around $12/yr, but if you would like a trendier domain, you can expect to pay more. Students may be able to get a free domain through NameCheap for Education.</p>"},{"location":"getting-started/deploying-to-aws/#set-up-an-ssl-certificate","title":"Set up an SSL certificate","text":"<p>In order to have encryption\u2014which you want!\u2014you need a certificate. You can get this for free through AWS, though it's particularly easy to set this up if you registered your domain through AWS as well:</p> <ol> <li>First, make sure you are in the US-East-1 zone. (This matters.)</li> <li>In the AWS Certificate Manager, select \"Provision Certificate\"</li> <li>Request a public certificate.</li> <li>Enter two your domain preceded by an <code>*</code> (thus 'gameswithwords.org' would be entered as <code>*.gameswithwords.org</code>).</li> <li>If you registered your domain with AWS, use DNS validation. Otherwise, follow the instructions.</li> <li>If you used AWS for your domain registration, Skip through the next couple of steps and click \"request\". If you did not, it may be more complicated. </li> <li>If you used AWS for your domain registration, select the certificate from the list of certificates. Scroll down to \"Domains\" and click \"Create records in Route 53\". Select the domain from the list.</li> </ol> <p>At this point, you wait for your certificate to be issued. Depending on how you registered your domain, this may take variable amounts of time. For us, it usually only takes a few minutes.</p> <p>SSL certificates set up outside of AWS vary in cost, but start around $8/year.</p>"},{"location":"getting-started/deploying-to-aws/#dockerhub","title":"DockerHub","text":"<p>Create a DockerHub account if you haven't already. Then tell Pushkin what your DockerHub ID is by running:</p> <pre><code> pushkin setDockerHub\n</code></pre> <p>You can change your ID at any point by re-running this command.</p>"},{"location":"getting-started/deploying-to-aws/#initializing-aws-deploy","title":"Initializing AWS deploy","text":"<p>Run:</p> <pre><code> pushkin aws init\n</code></pre> <p>You should be asked to name your project, to enter the aws profile you want to use (usually just \"default\"), choose a security certificate, and choose a domain name. In the latter two cases, the certificate and domain you created in the steps above should be available as options (if not, check that you completed those steps and can see the resources in the AWS console).</p> <p>It usually takes 5-10 minutes for the program to complete. It tends to stick at \"Finished syncing files\" and \"Creating ECS tasks,\" although the exact location could change in future versions. When the program successfully completes, you should be able to navigate to your website at your chosen domain.</p>"},{"location":"getting-started/deploying-to-aws/#what-do-i-do-if-aws-init-crashes","title":"What do I do if aws init crashes?","text":"<p>Deploying to AWS is very complicated. Sometimes, it will fail. Try debugging by doing the following in the following order:</p> <ol> <li>Try rerunning <code>pushkin aws init</code>.</li> <li>Try deleting your deploy (<code>pushkin aws armageddon</code>) and then running (<code>pushkin aws init --force</code>). The <code>--force</code> tag insures that any local aws config information is reset.</li> <li>Ask for help on the Pushkin forum. Post ALL of the output from your run of aws init.</li> </ol>"},{"location":"getting-started/deploying-to-aws/#deleting-your-aws-deploy","title":"Deleting your AWS deploy","text":"<p>AWS will charge you for services you have running. If you are just doing a test site, you may want to delete it afterwards to minimize charges. Run:</p> <pre><code> pushkin aws armageddon\n</code></pre> <p>When it completes, Armageddon will list remaining services that it hasn't deleted. Armageddon is usually unable to delete everything the first time. This is certain services can't be deleted until other services have finished deleting. You will usually see an error message. Wait a few minutes and run <code>pushkin aws armageddon</code>. The second time should be the charm. If you are still having problems, see \"deleting through the console\".</p> <p>To get the latest news and updates on Pushkin, sign up for our newsletter here.</p>"},{"location":"getting-started/deploying-to-aws/#view-your-data","title":"View Your Data","text":"<p>After you have deployed to AWS, you will want to view your data. </p> <p>An introduction to viewing your database with a Postgres manager is given in the Quickstart. Start there for information about how to download and install pgAdmin and how to view your data when testing locally.</p> <p>This tutorial will cover how to view your data from an AWS deployment. </p>"},{"location":"getting-started/deploying-to-aws/#setup","title":"Setup","text":"<ol> <li>Make sure your site has successfully been deployed using AWS. </li> <li>Open the <code>pushkin.yaml</code> for your site in a text editor.</li> <li>Start pgAdmin, which will open in your browser. </li> </ol>"},{"location":"getting-started/deploying-to-aws/#add-a-new-server","title":"Add a new server","text":"<p>By default, a database called Main is created when you deploy to AWS. Find this in your <code>pushkin.yaml</code>, which should look something like this:</p> <pre><code>experimentsDir: experiments\ncoreDir: pushkin\nDockerHubID: yourdockerhubid\ndatabases:\n  localtestdb:\n    user: postgres\n    pass: example\n    url: test_db\n    name: test_db\n    host: localhost\ninfo:\n  rootDomain: mydomain.com\n  whoAmI: Citizen Science Website\n  hashtags: 'science, learn'\n  email: me@mydomain.com\n  shortName: CSW\n  projName: myproject\n  awsName: myproject4c2da3b2-d5dc-4414-9d1f-9b30031333bb\naddons:\n  useForum: false\n  useAuth: true\n  authDomain: &lt;YOUR_AUTH0_DOMAIN&gt;\n  authClientID: &lt;YOUR_AUTH0_CLIENT_ID&gt;\nsalt: abc123\nfc:\n  popup: false\nproductionDBs:\n  Main:\n    type: Main\n    name: myprojectMain\n    host: myprojectmain.c3iwcrbpuehx.us-east-1.rds.amazonaws.com\n    user: postgres\n    pass: '0.9073399739822692'\n    port: 5432\n  Transaction:\n    type: Transaction\n    name: myprojectTransaction\n    host: myprojecttransaction.c3iwcrbpuehx.us-east-1.rds.amazonaws.com\n    user: postgres\n    pass: '0.8091098674547545'\n    port: 5432\n</code></pre> <p>Under <code>productionDBs</code>, find your <code>Main</code> database. You will need information from this section to complete the following steps:</p> <ol> <li>In the pgAdmin dashboard, under the Quick Links, click Add New Server.</li> <li>You can set the name of the server to anything, for example <code>Pushkin AWS Deploy</code>. </li> <li>Then move to the Connection tab and set Host name/address to <code>host</code> as it is specified in your <code>pushkin.yaml</code>. In the example above, it would be: <code>myprojectmain.c3iwcrbpuehx.us-east-1.rds.amazonaws.com</code>. </li> <li>Set the password to the your randomly generated password\u2014<code>0.9073399739822692</code> in the above example.</li> <li>Click Save and your Pushkin AWS Deploy server should appear in the left sidebar.</li> </ol>"},{"location":"getting-started/deploying-to-aws/#view-your-data_1","title":"View your data","text":"<p>To view your data tables, navigate to the left sidebar:</p> <ol> <li>Click to expand your Pushkin AWS Deploy server.</li> <li>Select myprojectMain under Databases. </li> <li>Select Schemas, which will also open its subitem public. </li> <li>Under public, choose Tables.</li> </ol> <p>By default, you should have 5 tables: <code>knex_migrations</code>, <code>knex_migrations_lock</code>, <code>pushkin_userMeta</code>, <code>pushkin_userResults</code>, and <code>pushkin_users</code>. You should also have one table for each experiment. If your experiment is called <code>mind</code>, you should have <code>mind_stimulusResponses</code>. </p> <p>To view a given table, right-click on it, hover over View/Edit Data, and click on All Rows, which will then appear in a new pgAdmin tab.</p> <p>For more information on how to use pgAdmin, you can read their documentation here.</p>"},{"location":"getting-started/installation/","title":"Installing Pushkin and its dependencies","text":"<p>Warning</p> <p>Due to an update in AWS resources, the CLI-based AWS deploy does not currently work and is being updated. In the meantime, you can still manually deploy to AWS.</p> <p>The first step for new users of Pushkin is to install Pushkin's command line interface (pushkin-cli), along with any of its dependencies which you haven't installed previously. Currently, Pushkin supports installation on macOS, Windows (via Ubuntu Linux), and GitHub Codespaces.</p> <p>Note</p> <p>Due to frequent compatibility issues with Windows, we strongly recommend Windows users consider using GitHub Codespaces. Future Pushkin releases may no longer support Windows.</p>"},{"location":"getting-started/installation/#setup","title":"Setup","text":"MacWindowsUbuntu LinuxGitHub Codespaces <p>If you haven't previously installed Homebrew, you'll need to install it. If you're not sure if you've previously installed it, you can try running <code>brew --version</code> in the terminal.</p> <p>If it's installed, you'll see the version (otherwise, the <code>brew</code> command will not be found). Installing Homebrew will require Xcode Command Line Tools. If you don't have Xcode Command Line Tools (or the entire Xcode distribution) installed yet, the Homebrew installation will prompt you to install that as well.</p> <p>Note</p> <p>Windows users should first complete these setup instructions before doing the setup steps for Ubuntu Linux.</p> <p>To use Pushkin, Windows users need to install Windows Subsystem for Linux (WSL) 2. Note that this process will require restarting your computer multiple times. This tutorial explains how to configure WSL 2 and install a Linux distribution from the Microsoft Store. We recommend using Ubuntu 20.04. </p> <p>While we recommend following the tutorial above for the most complete information about installing WSL, in most cases you can simply run Windows PowerShell as an administrator and run:</p> <pre><code>wsl --install\n</code></pre> <p>This will install WSL using the default configuration. It will prompt you to reboot your machine when it finishes. Do that, and then continue on.</p> <p>Pushkin requires using WSL 2. To check which version of WSL you are using, run the following command in Windows Powershell:</p> <pre><code>wsl --list --verbose\n</code></pre> <p></p> <p>This will give you a list of your installed Linux distributions and what version of WSL they are using. If your distribution is using WSL 1, run:</p> <pre><code>wsl --set-version &lt;distribution name&gt; 2\n</code></pre> <p>The distribution name should be the name given in the previous list for your Linux distribution.</p> <p>As the tutorial details, you will need Windows 10 version 2004 (or higher) or Windows 11 to be able to use WSL 2. If you follow the instructions in the tutorial and cannot update to version 2004, these steps may be able to help.</p> <p>After you have enabled WSL 2 and installed Ubuntu, you will probably also want to enable copy and paste in the terminal by right-clicking on the terminal window, selecting Properties and following these instructions.</p> <p></p> <p>Next, run the following commands in the Ubuntu terminal to update your Ubuntu packages. This (and other commands with <code>sudo</code> in front of them) will prompt you to give the Ubuntu password you set up when you installed it. It will also prompt you to respond with <code>y</code> and press ENTER to confirm that you would like to install or update software. </p> <pre><code>sudo apt update\nsudo apt upgrade\n</code></pre> <p></p> <p>For more on package management with apt, see the documentation. To learn more about the basics of the Linux command line, you can follow this tutorial.</p> <p>Next, follow the setup instructions for Ubuntu Linux.</p> <p>Note</p> <p>These instructions were created using Ubuntu 18.04 and the apt package manager. They should, however, generalize to other Linux distributions and package managers.</p> <p>Ensure that you have curl installed, as this will be necessary to download Node.js. If it isn't installed, you can install it using the following commands:</p> <pre><code>sudo apt update\nsudo apt install curl\n</code></pre> <p></p> <p>GitHub Codespaces is a cloud-based development environment powered by VS Code that allows you to develop entirely in the browser. If you use VS Code already, you can also use the Codespaces extension. Codespaces is not entirely free (see details here), but the free allocation of storage and compute time that comes with your GitHub account should be enough to acquaint yourself with the basics of Pushkin. </p> <p>To get started, go to Github Codespaces and select the blank template. This should open a development environment that will look quite familiar if you've previously used VS Code.</p> <p></p> <p>The standard Codespaces environment has most of Pushkin's dependencies pre-installed, but in order for Pushkin's commands to run properly, you need to add Yarn's global install location to the PATH by running this command in the terminal:</p> <pre><code>export PATH=\"$(yarn global bin):$PATH\"\n</code></pre>"},{"location":"getting-started/installation/#installing-node","title":"Installing Node","text":"MacUbuntu LinuxGitHub Codespaces <p>If you haven't installed Node previously, you should install it:</p> <pre><code>brew install node\n</code></pre> <p>You can check your version (or whether you've installed it) with <code>node --version</code>.</p> <p>You may additionally want to install nvm (Node version manager). To do so, run the following command:</p> <pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash\n</code></pre> <p>At this point, you may need to close and reopen your terminal for the <code>nvm</code> command to be recognized. Then run:</p> <pre><code>nvm install 20.2.0\n</code></pre> <p>See here if installation issues persist.</p> <p>If you want to switch your preferred version of Node.js, use the following commands:</p> <pre><code>nvm install &lt;node_version&gt;\nnvm use &lt;node_version&gt;\n</code></pre> <p>To install Node.js, first run the following command to install nvm (Node version manager):</p> <pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash\n</code></pre> <p>Then use nvm to install Node.js:</p> <pre><code>nvm install 20.2.0\n</code></pre> <p>If the <code>nvm</code> command isn't recognized, you may need to close and reopen your terminal. Alternatively, try running <code>source ~/.  bashrc</code> (see here).</p> <p>If you want to switch your preferred version of Node.js, use the following commands:</p> <pre><code>nvm install &lt;node_version&gt;\nnvm use &lt;node_version&gt;\n</code></pre> <p></p> <p>Node and nvm (Node version manager) come pre-installed in the Codespaces environment, so you can skip to the next step.</p> <p>You can check your version with <code>node --version</code>. If you did ever want to switch your version of Node.js, you can use the following commands:</p> <pre><code>nvm install &lt;node_version&gt;\nnvm use &lt;node_version&gt;\n</code></pre>"},{"location":"getting-started/installation/#installing-yarn","title":"Installing Yarn","text":"MacUbuntu LinuxGitHub Codespaces <p>You will next need to install the Yarn package manager, which will let you download Pushkin. Run the following command:</p> <pre><code>brew install yarn\n</code></pre> <p></p> <p>You can check your version with <code>yarn --version</code>.</p> <p>You will next need to install the Yarn package manager, which will let you download Pushkin. Official instructions (copied below for convenience) are available here.</p> <p>Use npm, which comes bundled with Node.js that you just installed:</p> <pre><code>npm install --global yarn\n</code></pre> <p>Then check that Yarn is installed by running:</p> <pre><code>yarn --version\n</code></pre> <p></p> <p>In order to run Pushkin, you'll need to allow yarn to install packages globally. To do so, run the following commands, based on this Stack Overflow solution:</p> <pre><code>yarn config set prefix ~/.yarn\necho -e '\\nexport PATH=\"$PATH:`yarn global bin`\"\\n' &gt;&gt; ~/. bashrc\nsource ~/. bashrc\n</code></pre> <p></p> <p>Yarn comes pre-installed in the Codespaces environment, so you can skip to the next step.</p> <p>You can check your version with <code>yarn --version</code>. If you did ever want to switch your version of Yarn, you can use the following command:</p> <pre><code>npm install --global yarn@&lt;yarn_version&gt;\n</code></pre>"},{"location":"getting-started/installation/#installing-yalc","title":"Installing yalc","text":"MacUbuntu LinuxGitHub Codespaces <p>Next, install yalc globally:</p> <pre><code>yarn global add yalc\n</code></pre> <p></p> <p>Install Yalc globally:</p> <pre><code>yarn global add yalc\n</code></pre> <p></p> <p>Install yalc globally:</p> <pre><code>yarn global add yalc\n</code></pre>"},{"location":"getting-started/installation/#installing-pushkin-cli","title":"Installing pushkin-cli","text":"MacUbuntu LinuxGitHub Codespaces <p>Then install the Pushkin command line interface globally:</p> <pre><code>yarn global add pushkin-cli\n</code></pre> <p></p> <p>Confirm that pushkin-cli is installed by running:</p> <pre><code>pushkin --help\n</code></pre> <p>You should see a list of commands with some documentation for each.</p> <p></p> <p>Confirm that you have version <code>2.0.0</code> or later by running:</p> <pre><code>pushkin --version\n</code></pre> <p>Then install the Pushkin command line interface globally:</p> <pre><code>yarn global add pushkin-cli\n</code></pre> <p></p> <p>Confirm that pushkin-cli is installed by running:</p> <pre><code>pushkin --help\n</code></pre> <p>You should get a list of commands with some documentation for each.</p> <p></p> <p>Confirm that you have version <code>2.0.0</code> or later by running:</p> <pre><code>pushkin --version\n</code></pre> <p>Then install the Pushkin command line interface globally:</p> <pre><code>yarn global add pushkin-cli\n</code></pre> <p>Confirm that pushkin-cli is installed by running:</p> <pre><code>pushkin --help\n</code></pre> <p>You should see a list of commands with some documentation for each.</p> <p>Confirm that you have version <code>2.0.0</code> or later by running:</p> <pre><code>pushkin --version\n</code></pre>"},{"location":"getting-started/installation/#installing-docker","title":"Installing Docker","text":"MacUbuntu LinuxGitHub Codespaces <p>Next, install Docker.</p> <p></p> <p>Confirm that you have at least Docker Engine 23.0 by running <code>docker --version</code>.</p> <p>Next, install Docker Engine using these instructions (copied below for convenience).</p> <pre><code>sudo apt-get update\nsudo apt-get install ca-certificates curl gnupg\n</code></pre> <p></p> <p>Add Docker\u2019s official GPG key:</p> <pre><code>sudo install -m 0755 -d /etc/apt/keyrings\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\nsudo chmod a+r /etc/apt/keyrings/docker.gpg\n</code></pre> <p>Use the following command to set up the repository:</p> <pre><code>echo \\\n\"deb [arch=\"$(dpkg --print-architecture)\" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\n\"$(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\")\" stable\" | \\\nsudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n</code></pre> <p></p> <p>Next, update the apt package index:</p> <pre><code>sudo apt-get update\n</code></pre> <p>Install Docker Engine, containerd, and Docker Compose:</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose docker-compose-plugin\n</code></pre> <p></p> <p>Check that Docker Engine is installed correctly by running:</p> <pre><code>sudo docker run hello-world\n</code></pre> <p>If Docker Engine and Docker Compose are installed correctly, this should generate some output, including:</p> <pre><code>Hello from Docker!\nThis message shows that your installation appears to be working correctly.\n</code></pre> <p></p> <p>Next, follow these post-installation instructions (copied below for convenience) to manage Docker as a non-root user. You can ignore the other post-installation instructions.</p> <pre><code>sudo groupadd docker\nsudo usermod -aG docker $USER\nnewgrp docker \ndocker run hello-world\n</code></pre> <p></p> <p>Docker is already installed in the Codespaces environment. You can confirm this by running <code>docker --version</code>.</p>"},{"location":"getting-started/installation/#installing-a-postgres-manager","title":"Installing a Postgres manager","text":"<p>One of Pushkin's notable features is automatically setting up a PostgreSQL database where all of your website's experiments' data will be stored. In order to view, manipulate, or download the data, you're probably going to want a Postgres manager. There are many options for this type of software (paid and free), or you could avoid the need for a Postgres manager altogether and interact with the database solely through the command line (not documented here).</p> <p>Two free options which should serve the needs of beginning users are pgAdmin or SQLTools (with the corresponding PostgreSQL driver). pgAdmin is a standalone desktop app, while SQLTools is an extension for VS Code. You can install either option from the links above. If you choose SQLTools, be sure to also install the extension \"SQLTools PostgreSQL/Cockroach Driver\".</p> <p>For Codespaces users:</p> <p>Your easiest option for a Postgres manager will probably be adding a VS Code extension within your codespace. Select the \"Extensions\" tab on the left side of the window and search for \"SQLTools\" and \"SQLTools PostgreSQL/Cockroach Driver\". After installing those two extensions, you're ready to continue.</p>"},{"location":"getting-started/installation/#next-steps","title":"Next steps","text":"<p>If you've completed those steps successfully, you're ready to start using Pushkin! At this point, we recommend working through our quickstart and simple experiment tutorials to familiarize yourself with the basic Pushkin commands and experiment structure. From there, you might want to read about AWS deployment or explore the details of experiment templates.</p>"},{"location":"getting-started/quickstart/","title":"Quickstart tutorial","text":"<p>Note</p> <p>You should complete the installation of pushkin-cli and its dependencies before beginning this tutorial.</p>"},{"location":"getting-started/quickstart/#starting-docker","title":"Starting Docker","text":"<p>First, open Docker Desktop and make sure Docker Engine is running. You can check by running <code>docker ps</code> in the terminal, which will show a list of your running containers, which should be empty at this point:</p> <pre><code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES\n</code></pre> <p>If Docker isn't running, you'll see a message that you \"cannot connect to the Docker daemon\".</p>"},{"location":"getting-started/quickstart/#creating-a-basic-pushkin-site","title":"Creating a basic Pushkin site","text":"<p>Create a new directory (e.g., <code>pushkin_quickstart</code>) in a location of your choosing (we'll use the Desktop here) and enter this directory using the following commands:</p> <pre><code>cd Desktop\nmkdir pushkin_quickstart\ncd pushkin_quickstart\n</code></pre> <p>(For more on basic terminal commands, you can check out this blog post.)</p> <p>Install your pushkin site in the directory you just created:</p> <p><pre><code>pushkin install site\n</code></pre> You will be asked where you want to look for a site template. Choose Official Pushkin distribution.  You will then be asked to select a site template to use. Choose site-basic; then choose the recommended version.</p> <p>This sets up a skeleton website in the current folder and a development database. Once the command finishes, you should have a directory tree like this:</p> <pre><code>\u251c\u2500\u2500 experiments\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 pushkin\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 api\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 docker-compose.dev.yml\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 front-end\n\u251c\u2500\u2500 pushkin.yaml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 users\n    \u251c\u2500\u2500 config.yaml\n    \u2514\u2500\u2500 migrations\n</code></pre>"},{"location":"getting-started/quickstart/#updating-site-config-options","title":"Updating site config options","text":"<p>Open <code>pushkin.yaml</code> in your project root directory. It should look something like:</p> <pre><code>experimentsDir: experiments\ncoreDir: pushkin\nDockerHubID: ''\ndatabases:\n  localtestdb:\n    user: postgres\n    pass: example\n    url: localhost\n    port: '5432'\n    name: test_db\n    host: test_db\n  localtransactiondb:\n    user: postgres\n    pass: example\n    host: test_transaction_db\n    port: '5433'\n    url: localhost\n    name: test_transaction_db\ninfo:\n  rootDomain: localhost\n  whoAmI: Citizen Science Website\n  hashtags: 'science, learn'\n  email: me@mydomain.com\n  shortName: CSW\naddons:\n  useForum: false\n  useAuth: false\nsalt: abc123\nfc:\n  popup: false\n</code></pre> <p>You can ignore most of these settings for now, but you should probably change:</p> <ul> <li>whoAmI: This is the name of your website that will be displayed to users</li> <li>hashtags: These are hashtags used for social media</li> <li>email: An email where notifications, etc., will be sent to.</li> <li>shortName: An abbreviated name of your website</li> </ul> <p>The one you should definitely change is <code>salt</code>. This is used to encrypt private information. Type in any alphanumeric text here, for instance:</p> <pre><code>salt: \"cognitivescience\"\n</code></pre>"},{"location":"getting-started/quickstart/#adding-experiments","title":"Adding experiments","text":"<p>To add experiments to your Pushkin site, run:</p> <pre><code>pushkin install experiment\n</code></pre> <p>You'll first be asked what you want to name your experiment. Call it <code>hello</code>, since we're going to make this experiment a simple \"hello, world\" example.</p> <p>You'll then be asked where you want to look for experiment templates; choose Official Pushkin distribution. </p> <p>Then you'll be asked which experiment template you want to use. The exp-basic template is a bare-bones \"hello, world\" experiment. Choose exp-basic and then select the recommended version of the template. Choose 'no' when asked if you want to import a jsPsych experiment (this option only applies to the basic template).</p> <p>Repeat the process above but this time select the lexical-decision template. You can call this one <code>lexdec</code>. Now do the same thing for the grammaticality-judgment and self-paced-reading templates, naming them <code>gram</code> and <code>spr</code>.</p> <p>The <code>experiments</code> directory of your site should now look like this:</p> <pre><code>\u2514\u2500\u2500 gram\n    \u251c\u2500\u2500 api controllers\n    \u251c\u2500\u2500 config.yaml\n    \u251c\u2500\u2500 LICENSE\n    \u251c\u2500\u2500 migrations\n    \u251c\u2500\u2500 README.md\n    \u251c\u2500\u2500 web page\n    \u2514\u2500\u2500 worker\n\u2514\u2500\u2500 hello\n    \u251c\u2500\u2500 api controllers\n    \u251c\u2500\u2500 config.yaml\n    \u251c\u2500\u2500 LICENSE\n    \u251c\u2500\u2500 migrations\n    \u251c\u2500\u2500 README.md\n    \u251c\u2500\u2500 web page\n    \u2514\u2500\u2500 worker\n\u2514\u2500\u2500 lexdec\n    \u251c\u2500\u2500 api controllers\n    \u251c\u2500\u2500 config.yaml\n    \u251c\u2500\u2500 LICENSE\n    \u251c\u2500\u2500 migrations\n    \u251c\u2500\u2500 README.md\n    \u251c\u2500\u2500 web page\n    \u2514\u2500\u2500 worker\n\u2514\u2500\u2500 spr\n    \u251c\u2500\u2500 api controllers\n    \u251c\u2500\u2500 config.yaml\n    \u251c\u2500\u2500 LICENSE\n    \u251c\u2500\u2500 migrations\n    \u251c\u2500\u2500 README.md\n    \u251c\u2500\u2500 web page\n    \u2514\u2500\u2500 worker\n</code></pre> <p>Each experiment has its own configuration file (<code>config.yaml</code>), which allows you to make a number of customizations, e.g. defining a longer human-readable name for the experiment:</p> <pre><code>experimentName: 'My super fun experiment!'\n</code></pre>"},{"location":"getting-started/quickstart/#reorganizing-your-site-for-testingdeployment","title":"Reorganizing your site for testing/deployment","text":"<p>Keeping all the files for an experiment within the same root folder is convenient for development, but not for actually deploying the website. To reorganize your site for deployment (and local testing), run:</p> <pre><code>pushkin prep\n</code></pre> <p>Note</p> <p>Don't worry: <code>pushkin prep</code> won't jumble up the files in the <code>pushkin_quickstart</code> directory you created; rather it reorganizes the files into Docker containers. There's never any need to \"unprep\" your site. You can run <code>pushkin prep</code>, make changes in your local site directory, re-run <code>pushkin prep</code>, and the changes you made will be reflected in Docker.</p>"},{"location":"getting-started/quickstart/#testing-your-site-locally","title":"Testing your site locally","text":"<p>Now let\u2019s look at your website! Start your local deploy by running:</p> <pre><code>pushkin start\n</code></pre> <p>In a web browser, open localhost and you should see your site with the experiments you made. Click on the one you called <code>hello</code>. It should display \"Hello world!\". Complete the experiment by pressing any key. If you want to take a look at the other experiments you made, feel free to look over those now too.</p> <p>When you are done looking at your website, stop the local deploy by running:</p> <pre><code>pushkin stop\n</code></pre> <p>If you don\u2019t do that, the web server will keep running in Docker until you quit Docker or restart. When the command has finished running, it should output <code>done</code>.</p>"},{"location":"getting-started/quickstart/#site-testing-with-github-codespaces","title":"Site testing with GitHub Codespaces","text":"<p>If you are developing your Pushkin site in a codespace, you'll run <code>pushkin start</code> just like for local testing; however, to view your site, click on the \"PORTS\" tab and click the globe icon for port 80 to open your site in the browser:</p> <p></p> <p>If you notice CORS errors in the console while testing your site in a codespace, a potential fix can be to make port 80 public:</p> <p></p> <p>After you're done looking at your site, run <code>pushkin stop</code> just as you would for local testing.</p>"},{"location":"getting-started/quickstart/#updating-your-site","title":"Updating your site","text":"<p>Imagine now you want to add another experiment or edit an existing one. Every time you update your site, you\u2019ll need to run <code>pushkin prep</code> (and <code>pushkin start</code> if you want to look at your updates) again:</p> <pre><code>pushkin prep\npushkin start\n</code></pre>"},{"location":"getting-started/quickstart/#removing-experiments","title":"Removing experiments","text":"<p>If you'd like to get rid of one or more of your site's experiments, you can remove them with this command:</p> <pre><code>pushkin remove experiment\n</code></pre> <p>There are two options when removing an experiment, archive and delete. Archiving an experiment simply removes it from your site's front end. This means that the experiment will no longer be accessible to participants. Archiving an experiment can be undone by calling <code>pushkin remove experiment</code> again and specifying the <code>unarchive</code> mode. Deleting an experiment removes all of its files, data, and Docker components. Deleting an experiment is irreversible, so be sure you want the experiment gone before using this mode.</p> <p>Warning</p> <p>For technical reasons, the current implementation of the <code>delete</code> mode deletes all experiments' data from your local database, not just the experiment(s) you deleted. Future development may address this limitation.</p> <p>Since the <code>remove experiment</code> command updates your site, you will need to run <code>pushkin prep</code> afterwards just like if you added an experiment or edited other parts of your site.</p>"},{"location":"getting-started/quickstart/#viewing-your-data","title":"Viewing your data","text":"<p>At this point, you should have generated some data by testing at least one of your experiments. In order to view it, you can use whatever Postgres manager you installed based on the Pushkin installation instructions. Here, we'll go over how to view the data using either pgAdmin or SQLTools. Make sure your database is running first by using the command <code>pushkin start</code>.</p> pgAdminSQLTools <p>When you start pgAdmin, it will take a moment to load and then will appear as a new tab in your web browser. When you install it the first time, it will ask you to set a master password. This can be whatever you'd like, but make sure you keep it in a secure place.</p> <p></p> <p>Under Quick Links, click Add New Server. Make sure you have run <code>pushkin start</code> and that your site is running in <code>localhost</code>. Then follow these steps:</p> <ol> <li>You can set the name of the server to anything, e.g. <code>Pushkin Testing</code>.</li> <li>Then move to the Connection tab and set Host name/address to <code>localhost</code>.</li> <li>Set the password to the default password, <code>example</code>, which you can find in <code>pushkin.yaml</code>.</li> <li>Click Save and your Pushkin Testing server should appear in the left sidebar.</li> </ol> <p></p> <p>To view your data tables, navigate to the left sidebar:</p> <ol> <li>Click to expand your Pushkin Testing server.</li> <li>Select test_db under Databases.</li> <li>Select Schemas, which will also open its subitem public.</li> <li>Under public, choose Tables. </li> </ol> <p></p> <p>You should see a list of tables including some that end in <code>_stimulusResponses</code> corresponding to each of your experiments. Right click any one of those, hover over View/Edit Data, and click on All Rows, which will open a new pgAdmin tab displaying the records in that table.</p> <p></p> <p>For more information on how to use pgAdmin, you can read their documentation here.</p> <p>The following instructions should work whether you're using the desktop VS Code application or browser-based VS Code via GitHub Codespaces. Assuming you have installed SQLTools and the necessary Postgres driver, click on the SQLTools tab on the left side of the window. Click Add New Connection and you'll see some fields you need to fill out:</p> <p></p> <p>Name the connection whatever you want. We'll call it <code>Pushkin Test</code> here. For the database and username, fill in <code>test_db</code> and <code>postgres</code> respectively. These are Pushkin's default database configurations. For the Use password field, select Ask on connect. Click SAVE CONNECTION at the bottom of that screen. You should now be prompted to fill in the password (<code>example</code>, unless you changed it earlier in you site's config file).</p> <p>You should see your connection in the left-hand window of the screen. Now select Pushkin Test &gt; test_db &gt; Schemas &gt; public &gt; Tables.</p> <p></p> <p>You should see a list of tables including some that end in <code>_stimulusResponses</code> corresponding to each of your experiments. Right click any of those and select Show Table Records. You should now see any data you created for that experiment.</p>"},{"location":"getting-started/quickstart/#starting-over","title":"Starting over","text":"<p>In some cases, you may find that editing your local code does not change what Docker thinks the code is. If you are updating something, but it\u2019s not showing up in localhost, the issue may be related to Docker. You may also see Docker-related error messages. Ideally, in these cases, you should read up on Docker. However, as a fail-safe, you can run <code>pushkin kill</code> to delete all your Pushkin-specific code in Docker. Then just run <code>pushkin prep</code> again. This will take a while but should address any Docker-specific problems. If you really need a fresh Docker install, run <code>pushkin armageddon</code>, which will completely clean Docker.</p>"},{"location":"getting-started/simple-experiment-tutorial/","title":"Tutorial: A simple experiment","text":"<p>The tutorial below starts with a simple lexical-decision task written in plain jsPsych 7 and explains how to modify this code to run in Pushkin. This is a recommended tutorial for learning the ropes, but a more complete lexical-decision experiment template is available to install through the Pushkin CLI.</p> <p>If you are not familiar with jsPsych, please consult their documentation. At a minimum, you should understand the basics of timelines and plugins in jsPsych.</p> <p>Note</p> <p>As of v3.6 of <code>pushkin-cli</code>, the procedures described here for moving the timeline and importing plugins can be automated if you choose to import a jsPsych experiment during <code>pushkin install experiment</code> and select the basic template (v5+). You can still do these tasks manually if you choose. You may also need to do parts of these procedures in the course of modifying one of the other experiment templates.</p>"},{"location":"getting-started/simple-experiment-tutorial/#initial-jspsych-code","title":"Initial jsPsych code","text":"<p>We will start with a simple lexical-decision experiment. The code has been adapted from the experiment here in order to be compatible with jsPsych 7. If you save the code below as a <code>.html</code> file, you should be able to run it as a standalone jsPsych experiment:</p> lexical-decision.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My experiment&lt;/title&gt;\n    &lt;script src=\"https://unpkg.com/jspsych@7.3.3\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.2\"&gt;&lt;/script&gt;\n    &lt;link\n      href=\"https://unpkg.com/jspsych@7.3.3/css/jspsych.css\"\n      rel=\"stylesheet\"\n      type=\"text/css\"\n    /&gt;\n    &lt;style&gt;\n      .fixation {\n        border: 2px solid black;\n        height: 100px;\n        width: 200px;\n        font-size: 24px;\n        position: relative;\n        margin: auto;\n      }\n      .fixation p {\n        width: 100%;\n        position: absolute;\n        margin: 0.25em;\n      }\n      .fixation p.top {\n        top: 0px;\n      }\n      .fixation p.bottom {\n        bottom: 0px;\n      }\n      .correct {\n        border-color: green;\n      }\n      .incorrect {\n        border-color: red;\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;&lt;/body&gt;\n  &lt;script&gt;\n    const stimArray = [\n      { word_1: 'SOCKS', word_2: 'SHOE', both_words: true, related: true },\n      { word_1: 'SLOW', word_2: 'FAST', both_words: true, related: true },\n      { word_1: 'QUEEN', word_2: 'KING', both_words: true, related: true },\n      { word_1: 'LEAF', word_2: 'TREE', both_words: true, related: true },\n\n      { word_1: 'SOCKS', word_2: 'TREE', both_words: true, related: false },\n      { word_1: 'SLOW', word_2: 'SHOE', both_words: true, related: false },\n      { word_1: 'QUEEN', word_2: 'FAST', both_words: true, related: false },\n      { word_1: 'LEAF', word_2: 'KING', both_words: true, related: false },\n\n      { word_1: 'AGAIN', word_2: 'PLAW', both_words: false, related: false },\n      { word_1: 'BOARD', word_2: 'TRUDE', both_words: false, related: false },\n      { word_1: 'LIBE', word_2: 'HAIR', both_words: false, related: false },\n      { word_1: 'MOCKET', word_2: 'MEET', both_words: false, related: false },\n\n      { word_1: 'FLAFF', word_2: 'PLAW', both_words: false, related: false },\n      { word_1: 'BALT', word_2: 'TRUDE', both_words: false, related: false },\n      { word_1: 'LIBE', word_2: 'NUNE', both_words: false, related: false },\n      { word_1: 'MOCKET', word_2: 'FULLOW', both_words: false, related: false }\n    ];\n\n    const jsPsych = initJsPsych();\n\n    const timeline = [];\n\n    var welcome = {\n      type: jsPsychHtmlKeyboardResponse,\n      stimulus:`\n        &lt;p&gt;Welcome!&lt;/p&gt;\n        &lt;p&gt;Press spacebar to continue.&lt;/p&gt;\n      `,\n      choices: [\" \"],\n    };\n\n    timeline.push(welcome);\n\n    var instructions_1 = {\n      type: jsPsychHtmlKeyboardResponse,\n      stimulus: `\n        &lt;p&gt;You will see two sets of letters displayed in a box, like this:&lt;/p&gt;\n        &lt;div class=\"fixation\"&gt;&lt;p class=\"top\"&gt;HELLO&lt;/p&gt;&lt;p class=\"bottom\"&gt;WORLD&lt;/p&gt;&lt;/div&gt;\n        &lt;p&gt;Press Y if both sets are valid English words. Press N if one or both is not a word.&lt;/p&gt;\n        &lt;p&gt;Press Y to continue.&lt;/p&gt;\n      `,\n      choices: [\"y\"],\n    };\n\n    timeline.push(instructions_1);\n\n    var instructions_2 = {\n      type: jsPsychHtmlKeyboardResponse,\n      stimulus: `\n        &lt;p&gt;In this case, you would press N.&lt;/p&gt;\n        &lt;div class=\"fixation\"&gt;&lt;p class=\"top\"&gt;FOOB&lt;/p&gt;&lt;p class=\"bottom\"&gt;ARTIST&lt;/p&gt;&lt;/div&gt;\n        &lt;p&gt;Press N to begin the experiment.&lt;/p&gt;\n      `,\n      choices: [\"n\"],\n    };\n\n    timeline.push(instructions_2);\n\n    var lexical_decision_procedure = {\n      timeline: [\n        {\n          type: jsPsychHtmlKeyboardResponse,\n          stimulus: '&lt;div class=\"fixation\"&gt;&lt;/div&gt;',\n          choices: \"NO_KEYS\",\n          trial_duration: 1000,\n        },\n        {\n          type: jsPsychHtmlKeyboardResponse,\n          stimulus: function () {\n            let first_word = jsPsych.timelineVariable(\"word_1\");\n            let second_word = jsPsych.timelineVariable(\"word_2\");\n            first_word =\n              '&lt;div class=\"fixation\"&gt;&lt;p class=\"top\"&gt;' + first_word + \"&lt;/p&gt;\";\n            second_word =\n              '&lt;div class=\"fixation\"&gt;&lt;p class=\"bottom\"&gt;' + second_word + \"&lt;/p&gt;\";\n            return first_word + second_word;\n          },\n          choices: [\"y\", \"n\"],\n          data: {\n            both_words: jsPsych.timelineVariable(\"both_words\"),\n            related: jsPsych.timelineVariable(\"related\"),\n          },\n          on_finish: function (data) {\n            if (data.both_words) {\n              data.correct = jsPsych.pluginAPI.compareKeys(data.response, \"y\");\n            } else {\n              data.correct = jsPsych.pluginAPI.compareKeys(data.response, \"n\");\n            }\n          },\n        },\n        {\n          type: jsPsychHtmlKeyboardResponse,\n          stimulus: function () {\n            let last_correct = jsPsych.data\n              .getLastTrialData()\n              .values()[0].correct;\n            if (last_correct) {\n              return '&lt;div class=\"fixation correct\"&gt;&lt;/div&gt;';\n            } else {\n              return '&lt;div class=\"fixation incorrect\"&gt;&lt;/div&gt;';\n            }\n          },\n          choices: \"NO_KEYS\",\n          trial_duration: 2000,\n        },\n      ],\n      timeline_variables: stimArray,\n      randomize_order: true,\n    };\n\n    timeline.push(lexical_decision_procedure);\n\n    var data_summary = {\n      type: jsPsychHtmlKeyboardResponse,\n      stimulus: function () {\n        // Calculate performance on task\n        let correct_related = jsPsych.data\n          .get()\n          .filter({ related: true, correct: true })\n          .count();\n        let total_related = jsPsych.data\n          .get()\n          .filter({ related: true })\n          .count();\n        let mean_rt_related = jsPsych.data\n          .get()\n          .filter({ related: true, correct: true })\n          .select(\"rt\")\n          .mean();\n\n        let correct_unrelated = jsPsych.data\n          .get()\n          .filter({ related: false, both_words: true, correct: true })\n          .count();\n        let total_unrelated = jsPsych.data\n          .get()\n          .filter({ related: false, both_words: true })\n          .count();\n        let mean_rt_unrelated = jsPsych.data\n          .get()\n          .filter({ related: false, both_words: true, correct: true })\n          .select(\"rt\")\n          .mean();\n\n        // Show results\n        let results = `&lt;p&gt;You were correct on ${correct_related} of ${total_related} related word pairings!\n            Your average correct response time for these was ${Math.round(\n              mean_rt_related\n            )} milliseconds.&lt;/p&gt;\n            &lt;p&gt;For unrelated word pairings, you were correct on ${correct_unrelated} of ${total_unrelated}!\n            Your average correct response time for these was ${Math.round(\n              mean_rt_unrelated\n            )} milliseconds.&lt;/p&gt;`;\n        return results;\n      },\n      choices: \"NO_KEYS\",\n    };\n\n    timeline.push(data_summary);\n\n    jsPsych.run(timeline);\n  &lt;/script&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"getting-started/simple-experiment-tutorial/#moving-the-timeline","title":"Moving the timeline","text":"<p>Following the same procedure as in the Quickstart, create a new basic Pushkin site using <code>pushkin install site</code> or navigate to the root directory of an existing Pushkin site. Now run:</p> <pre><code>pushkin install experiment\n</code></pre> <p>Call your experiment \"lexdec\" and select the latest version of the basic experiment template. Choose 'no' when asked if you'd like to import a jsPsych experiment.</p> <p>You should now have a folder in your site called <code>/experiments/lexdec</code> with the following content:</p> <pre><code>\u2514\u2500\u2500 lexdec\n    \u251c\u2500\u2500 api controllers\n    \u251c\u2500\u2500 config.yaml\n    \u251c\u2500\u2500 migrations\n    \u251c\u2500\u2500 web page\n    \u2502    \u2514\u2500\u2500 src\n    \u2502         \u251c\u2500\u2500 assets\n    \u2502         \u251c\u2500\u2500 experiment.js\n    \u2502         \u251c\u2500\u2500 experiment.test.js\n    \u2502         \u2514\u2500\u2500 index.js\n    \u2514\u2500\u2500 worker\n</code></pre> <p>Open <code>/lexdec/web page/src/experiment.js</code>. It should look like this:</p> experiment.js<pre><code>import jsPsychHtmlKeyboardResponse from '@jspsych/plugin-html-keyboard-response';\n\nexport function createTimeline(jsPsych) {\n    const timeline = []\n\n    var hello_trial = {\n        type: jsPsychHtmlKeyboardResponse,\n        stimulus: 'Hello, world!'\n    }\n\n    timeline.push(hello_trial);\n\n    return timeline;\n}\n</code></pre> <p>From the jsPsych code above, copy everything between <code>const timeline = []</code> and <code>jsPsych.run(timeline);</code> (excluding those lines). Paste that content into <code>experiment.js</code> (replacing the existing content) between <code>const timeline = []</code> and <code>return timeline</code>. Thus you should now have a function <code>createTimeline()</code> within which you build up and finally return the timeline for the experiment.</p>"},{"location":"getting-started/simple-experiment-tutorial/#importing-plugins","title":"Importing plugins","text":"<p>In the jsPsych code above, plugins are loaded with <code>&lt;script&gt;</code> tags. In a Pushkin experiment, plugins are loaded with <code>import</code> statements. The basic template already includes the <code>html-keyboard-response</code> plugin as a dependency, so no additional modifications are needed. If you wanted to add additional jsPsych plugins to this experiment, you would use additional <code>import</code> statements in the same format described in the overview of experiment templates.</p>"},{"location":"getting-started/simple-experiment-tutorial/#moving-the-stimuli","title":"Moving the stimuli","text":"<p>In theory, there's nothing preventing you from declaring your stimuli inside <code>experiment.js</code> in the same way as shown above in <code>lexical-decision.html</code>; however, we can keep our <code>experiment.js</code> tidier by exporting the stimuli from a dedicated file <code>/lexdec/web page/src/stim.js</code> like this:</p> stim.js<pre><code>// Example stimuli\n\nconst stimArray = [\n    { word_1: 'SOCKS', word_2: 'SHOE', both_words: true, related: true },\n    { word_1: 'SLOW', word_2: 'FAST', both_words: true, related: true },\n    { word_1: 'QUEEN', word_2: 'KING', both_words: true, related: true },\n    { word_1: 'LEAF', word_2: 'TREE', both_words: true, related: true },\n\n    { word_1: 'SOCKS', word_2: 'TREE', both_words: true, related: false },\n    { word_1: 'SLOW', word_2: 'SHOE', both_words: true, related: false },\n    { word_1: 'QUEEN', word_2: 'FAST', both_words: true, related: false },\n    { word_1: 'LEAF', word_2: 'KING', both_words: true, related: false },\n\n    { word_1: 'AGAIN', word_2: 'PLAW', both_words: false, related: false },\n    { word_1: 'BOARD', word_2: 'TRUDE', both_words: false, related: false },\n    { word_1: 'LIBE', word_2: 'HAIR', both_words: false, related: false },\n    { word_1: 'MOCKET', word_2: 'MEET', both_words: false, related: false },\n\n    { word_1: 'FLAFF', word_2: 'PLAW', both_words: false, related: false },\n    { word_1: 'BALT', word_2: 'TRUDE', both_words: false, related: false },\n    { word_1: 'LIBE', word_2: 'NUNE', both_words: false, related: false },\n    { word_1: 'MOCKET', word_2: 'FULLOW', both_words: false, related: false }\n]\n\nexport default stimArray;\n</code></pre> <p>Then we need to import <code>stimArray</code> into <code>experiment.js</code> by adding the following line underneath the <code>import</code> statement for the plugin: </p> <pre><code>import stimArray from './stim';\n</code></pre>"},{"location":"getting-started/simple-experiment-tutorial/#moving-the-css-styling","title":"Moving the CSS styling","text":"<p>The experiment above relies on CSS styling from <code>&lt;link&gt;</code> and <code>&lt;style&gt;</code> tags to display the experiment correctly. This styling needs be moved to <code>/experiments/lexdec/web page/src/assets/experiment.css</code> in order to style your Pushkin experiment. The new CSS file will look like this:</p> experiment.css<pre><code>@import url('https://unpkg.com/jspsych@7.3.3/css/jspsych.css');\n\n/* Fixation box styling */\n.fixation {\n    border: 2px solid black;\n    height: 100px;\n    width: 200px;\n    font-size: 24px;\n    position: relative;\n    margin: auto;\n}\n.fixation p {\n    width: 100%;\n    position: absolute;\n    margin: 0.25em;\n}\n.fixation p.top {\n    top: 0px;\n}\n.fixation p.bottom {\n    bottom: 0px;\n}\n\n/* Color for box border when correct */\n.correct {\n    border-color: green;\n}\n\n/* Color for box border when incorrect */\n.incorrect {\n    border-color: red;\n}\n</code></pre>"},{"location":"getting-started/simple-experiment-tutorial/#finishing-up","title":"Finishing up","text":"<p>At this point, you should be ready to run <code>pushkin prep</code> and <code>pushkin start</code> to see your new experiment! Refer back to the Quickstart for guidance on these commands.</p>"},{"location":"packages/packages-overview/","title":"Overview of Pushkin packages","text":"<p>Pushkin is comprised of multiple modular packages:</p> <ul> <li><code>pushkin-cli</code> (npm): The centerpiece of the Pushkin ecosystem and the user's primary tool for creating their Pushkin site. When installed globally, the user can run <code>pushkin</code> commands to install, prepare, and deploy their site.</li> <li><code>pushkin-api</code> (npm): Essentially a mini-server designed with the use case of interfacing between pushkin-client and pushkin-worker via RabbitMQ.</li> <li><code>pushkin-client</code> (npm): A module that provides simplified methods for making calls to a Pushkin API and unpacking data sent back from a worker. Note that built-in functions assume the API has corresponding default routes enabled to handle such requests.</li> <li><code>pushkin-worker</code> (npm): Receives messages from RabbitMQ and runs whatever functionality it\u2019s told to run, sending the result back through the queue it came from. Designed to be on the receiving end of a Pushkin API. Comes with built-in simple functions that most users will probably want, like <code>getAllStimuli</code>.</li> </ul> <p>Note</p> <p>Technically, site and experiment templates are also implemented as packages; however, they are discussed in their own sections of the documentation.</p>"},{"location":"packages/pushkin-api/","title":"pushkin-api","text":""},{"location":"packages/pushkin-api/#api-controller-builder","title":"API Controller Builder","text":"<p>The controller builder is what most users will likely want to use for their experiment. It eases the creation of controllers that can be attached to a core Pushkin API. You can find the relevant file in <code>/experiments/&lt;experiment_name&gt;/api controllers/src</code>. Below is a simple example of how to use the controller builder:</p> <pre><code>import pushkin from 'pushkin-api';\nconst myController = new pushkin.ControllerBuilder();\n\nconst db_read_queue = 'myexp_quiz_dbread';\nconst db_write_queue = 'myexp_quiz_dbwrite';\nconst task_queue = 'myexp_quiz_taskworker';\n\nmyController.setDefaultPasses(db_read_queue, db_write_queue, task_queue);\nmyController.setDirectUse('/status', (req, res, next) =&gt; res.send('up'), 'get');\nmyController.setPass('/forum/posts', 'getAllForumPosts', db_read_queue, 'get');\nmyController.setPass('/forum/posts/:postid', 'getForumPost', db_read_queue, 'get');\n\nmodule.exports = myController;\n</code></pre> <p>The first line imports the API and the second creates a controller builder. The queues refer to specific queues to send information on through RabbitMQ. Using separate queues allows general categorization of data. For example, in the case of a crash, the write queue is backed up so as to avoid loss of research data during times of high traffic. The controller must be exported when done being modified so it can be required by the core API.</p> <p>The API layer of a Pushkin project has two main jobs. The first job is taking the request sent from the client, and the second job is sending the request to the message queue. Developers don't need to implement too many details about their experiments' logic in the API layer. All they need to do is design the endpoints and assign the message queues. For this, pushkin-api provides some methods to simplify the developer's job.</p> <p>For example, developers can use the <code>setPass()</code> method to assign HTTP requests to message queues by giving some simple arguments. They can also use <code>setDirectUse()</code> if there is no need to use the rpc and message queue in their controller design. Pushkin also provides the method <code>setDefaultPasses()</code> to provide a typical controller design of experiments, which only need some message queue arguments.</p>"},{"location":"packages/pushkin-api/#setpass","title":"setPass","text":"<p>Arguments:</p> <ul> <li>route: string</li> </ul> <p>The API endpoint that this pass applies to.</p> <ul> <li>rpcMethod: string</li> </ul> <p>What method to request the worker to perform.</p> <ul> <li>queue: string</li> </ul> <p>The RabbitMQ queue via which to send this pass.</p> <ul> <li>httpMethod: string</li> </ul> <p>The http method this endpoint will listen on.</p> <p>Returns: None</p> <p>When an <code>httpmethod</code> is sent to <code>/api/myexp/controllermountpath/route</code>, send an RPC call of <code>rpcMethod</code> through <code>queue</code> to a worker listening on the backend. This makes it easy for worker methods to be mapped to API endpoint URLS. When attached to a core API, this controller endpoint returns the data sent back by the worker to the client.</p>"},{"location":"packages/pushkin-api/#setdefaultpasses","title":"setDefaultPasses","text":"<p>Arguments:</p> <ul> <li>read queue: string</li> </ul> <p>Name of RabbitMQ read queue to use. Not persistent.</p> <ul> <li>write queue: string</li> </ul> <p>Name of RabbitMQ write queue to use. Persistent.</p> <ul> <li>task queue: string</li> </ul> <p>Name of RabbitMQ task queue to use. Not persistent.</p> <p>Returns: None</p> <p>Enable the default endpoints that a simple experiment would use. This makes it possible to use the default Pushkin Client calls. The default endpoints are:</p> <ul> <li><code>'/startExperiment', 'startExperiment', taskQueue, 'post'</code></li> <li><code>'/getStimuli', 'getStimuli', readQueue, 'post'</code></li> <li><code>'/metaResponse', 'insertMetaResponse', writeQueue, 'post'</code></li> <li><code>'/stimulusResponse', 'insertStimulusResponse', writeQueue, 'post'</code></li> <li><code>'/endExperiment', 'endExperiment', taskQueue, 'post'</code></li> </ul>"},{"location":"packages/pushkin-api/#setdirectuse","title":"setDirectUse","text":"<p>Arguments:</p> <ul> <li>route: string</li> </ul> <p>The API endpoint that this use applies to.</p> <ul> <li>handler: function</li> </ul> <p>Function to call when this endpoint is hit.</p> <ul> <li>httpMethod: string</li> </ul> <p>The http method this endpoint will listen on.</p> <p>Returns: None</p> <p>Applies this function to an API endpoint. The handler function is directly attached to an Express Router and should therefore take three arguments for the request, response, and next paramaters respectively.</p>"},{"location":"packages/pushkin-api/#getconnfunction","title":"getConnFunction","text":"<p>Arguments: None</p> <p>Returns: A function that takes a connection obj as the argument and will return a router/controller. This is the API of pushkin to handle the request to the current endpoint. The returned router/controller will be used as the <code>callback</code> argument of the <code>app.use([path,] callback [, callback...])</code></p> <p>Use this method to get the function and take a message queue connection as the argument. Then you can get the returned controller, which can be used as the argument of the  Core API's <code>useController</code> method. This method is usually used in the Core-API's <code>usePushkinController</code> method. When it gets the Pushkin controller, call this function with a message queue connection to finally get the Express router/controller.</p>"},{"location":"packages/pushkin-api/#core-api","title":"Core API","text":"<p>The Core API provides some methods which Pushkin can use to load the users's controllers. It will initilize the controllers and the connections with message queues, set up multiple middlewares, and start the server. The Core API of Pushkin works like this (see <code>/pushkin/api/src/index.js</code>):</p> <pre><code>import pushkin from 'pushkin-api';\n\nconst port = 3000;\nconst amqpAddress = 'amqp://localhost:5672';\n\nconst api = new pushkin.API(port, amqpAddress);\n\napi.init()\n     .then(() =&gt; {\n             const controllersFile = path.join(__dirname, 'controllers.json');\n             const controllers = JSON.parse(fs.readFileSync(controllersFile));\n             controllers.forEach(controller =&gt; {\n                     const mountPath = path.join('/api/', controller.mountPath);\n                     const contrModule = require(controller.name);\n                     console.log(contrModule);\n                     api.usePushkinController(mountPath, contrModule);\n             });\n             api.start();\n     })\n     .catch(console.error);\n</code></pre> <p>The first line imports the API and the following three create an api. After executing <code>api.init()</code>, the message queue will be connected. If the promise returned by <code>api.init()</code> is resolved, the controllers that users build will be loaded and used as the middleware by the Express App. Finally, when the <code>start()</code> method is called, the Express App will listen to the given port, and the server will start. The port defaults to <code>3000</code> and the <code>amqpAddress</code> defaults to <code>amqp://localhost:5672</code>.</p> <p>The core API's main jobs are taking the controllers built by the developer, using them in Express App, and starting the server. When developers finish designing their controllers, they can require the controllers as modules and use the <code>usePushkinController()</code> method to actually use the controllers in their server. Pushkin handles packaging the custom experiments.</p>"},{"location":"packages/pushkin-api/#init","title":"init","text":"<p>Arguments: None</p> <p>Returns: Promise, in which the connection to message queue is built. Once the connection succeeds, the Promise will be resolved and developers can define what to do next.</p>"},{"location":"packages/pushkin-api/#usecontroller","title":"useController","text":"<p>Arguments:</p> <ul> <li>route: string</li> </ul> <p>The API endpoint that this use applies to.</p> <ul> <li>controller: express.router</li> </ul> <p>The middleware function that can be used by Express App to handle the HTTP request.</p> <p>Returns: None</p> <p>An encapsulated method of Express <code>app.use(route, controller)</code>. Use it to add a controller/request handling method to a certain endpoint.</p>"},{"location":"packages/pushkin-api/#usepushkincontroller","title":"usePushkinController","text":"<p>Arguments:</p> <ul> <li>route: string</li> </ul> <p>The API endpoint that this use applies to.</p> <ul> <li>pushkinController: ControllerBuilder</li> </ul> <p>The controller created by users using Controller Builder. After users build their custom controllers in their experiments, pushkin-cli will package them up during the <code>pushkin prep</code> command.</p> <p>Returns: None</p> <p>Pushkin will package the experiment controllers that users develop and move them to <code>/pushkin/api</code>. With this method, Pushkin API will nest the Express router app for this experiment at the route <code>/api/&lt;exp&gt;</code>, where <code>&lt;exp&gt;</code> is the path for the experiment in question.</p>"},{"location":"packages/pushkin-api/#start","title":"start","text":"<p>Arguments: None</p> <p>Returns: None</p> <p>Start the server and listen to the given port.</p>"},{"location":"packages/pushkin-cli/","title":"pushkin-cli","text":""},{"location":"packages/pushkin-cli/#installation","title":"Installation","text":"<p>We recommend installing the Pushkin command-line interface globally for ease of setting up your Pushkin site:</p> <pre><code> yarn global add pushkin-cli\n</code></pre>"},{"location":"packages/pushkin-cli/#updating-pushkin-cli","title":"Updating pushkin-cli","text":"<p>To update Pushkin CLI to the most recently released version, run:</p> <pre><code> yarn global upgrade pushkin-cli --latest\n</code></pre>"},{"location":"packages/pushkin-cli/#commands","title":"Commands","text":""},{"location":"packages/pushkin-cli/#config","title":"config","text":"<p>View the config file for your site or any of the installed experiments. </p> <p>Syntax</p> <p><pre><code>pushkin config &lt;what&gt;\n</code></pre> Arguments</p> <ul> <li> <p>what: string</p> <p>Can be <code>site</code> or the name of any of the installed experiments. If omitted, all config files are shown.</p> </li> </ul>"},{"location":"packages/pushkin-cli/#install-site","title":"install site","text":"<p>This command uses a template to set up the file structure of your site in the current working directory. You will be prompted to select which template and version you want. Typically, the latest version will be the best option. You also have options to install a template from an arbitrary npm package(1) or from a local path. The latter option is particularly useful for developing your own site templates and for using unreleased development versions of templates.</p> <ol> <li>Of course, this will only work if the package is properly set up to function as a Pushkin site template.</li> </ol> How can I work on multiple Pushkin sites simultaneously? <p>When running Pushkin on your local system, you can only work on a single Pushkin site at a time. For most users, this shouldn't present a problem, since additional experiments can always be added to a site; however, if you do need to work on multiple sites simultaneously, using GitHub Codespaces will allow you to keep your sites in separate virtual environments.</p> <p>Syntax:</p> <pre><code>pushkin install site &lt;options&gt;\n</code></pre> <p>or</p> <pre><code>pushkin i site &lt;options&gt;\n</code></pre> <p>Options:</p> <ul> <li> <p>verbose: <code>-v</code> or <code>--verbose</code> shows additional console output during the installation process which may be helpful for debugging.</p> </li> <li> <p>help: <code>-h</code> or <code>--help</code> displays the command's help information.</p> </li> </ul> <p>Details:</p> <p>In general, it's a best practice to install your Pushkin site in a new directory. The CLI will ask you to confirm the installation if there are already contents in your working directory. In some cases you may wish to install a site into a directory that already has some contents, e.g. if the directory has already been initialized as a git repository and has a <code>/.git</code> directory.</p> <p><code>install site</code> generally works by initializing your site directory as a private npm package so Pushkin templates can be added as dependencies. Template contents then get unzipped into your site directory and are further manipulated by the CLI.</p> <p><code>install site</code> also sets up your Pushkin site\u2019s test transactions database, a test version of the eventual production transactions database. The command reviews the presence of configuration files <code>pushkin/docker-compose.dev.yml</code> and <code>pushkin.yaml</code>. These configurations detail the database setup, including parameters such as ports and passwords. Should necessary configurations for the test transaction database be absent, the command establishes them automatically. </p> <p>The transactions database, like all Pushkin databases, uses PostgreSQL and Knex migrations. Migration files serve as blueprints for database tables. If migration files for the transactions database are missing, the command automatically establishes a standard structure for it.</p> <p><code>install site</code> also does some initial dependency installation and building for the <code>/pushkin/front-end</code> and <code>/pushkin/api</code> components.</p>"},{"location":"packages/pushkin-cli/#install-experiment","title":"install experiment","text":"<p>This command helps users set up a new experiment using a Pushkin experiment template. You will be prompted to select which template and version you want. Typically, the latest version will be the best option. You also have options to install a template from an arbitrary npm package(1) or from a local path. The latter option is particularly useful for developing your own experiment templates and for using unreleased development versions of templates.</p> <ol> <li>Of course, this will only work if the package is properly set up to function as a Pushkin experiment template.</li> </ol> <p>Syntax:</p> <pre><code>pushkin install experiment &lt;options&gt;\n</code></pre> <p>or</p> <pre><code>pushkin i exp &lt;options&gt;\n</code></pre> <p>Options:</p> <ul> <li> <p>verbose: <code>-v</code> or <code>--verbose</code> shows additional console output during the installation process which may be helpful for debugging.</p> </li> <li> <p>help: <code>-h</code> or <code>--help</code> displays the command's help information.</p> </li> </ul> <p>Details:</p> <p>If you select the basic template, this command will give you the option to import an existing jsPsych experiment (note that the latest basic template and thus this feature only support jsPsych 7+). This feature assumes a workflow where you first implement the basics of your experiment design as a standalone jsPsych experiment, which is a bit faster to test, before turning it into a Pushkin experiment. This feature is covered in detail in the documentation for the basic experiment template.</p> <p><code>install experiment</code> generally works by adding the experiment template of your choosing as a dependency to your site. Template contents then get unzipped into the experiment's dedicated directory and are further manipulated by the CLI.</p> <p>The command also integrates a new experiment into the Pushkin framework. It performs key tasks such as updating template file names and contents to reflect the new experiment's name, setting up database migrations, initializing essential directories for the experiment's API, web page, and worker components, and ensuring the experiment is correctly configured in the Docker environment. The API and web page components are then locally published using yalc.</p>"},{"location":"packages/pushkin-cli/#remove-experiment","title":"remove experiment","text":"<p>This command allows users to remove an experiment from their site and offers three removal modes:</p> <ol> <li>delete: Deleting an experiment permanently removes all of its files, data, and associated Docker components. This command should only be used if you want the experiment completely gone, as it is irreversible. Note that this mode currently runs <code>kill</code>, and will consequently delete all experiments' data from your local database, not just the experiment(s) you deleted. Future development may address this limitation.</li> <li>archive: Archiving an experiment removes it from your site's front end, so it is no longer accessible to participants. However, all of the experiment's files remain in place and the site's back end and data will not be affected.</li> <li>pause-data: Pausing data collection means that the front end of the experiment stays accessible, but no data from subsequent runs of that experiment will be saved to the Pushkin database. When data collection is paused, an additional trial is added to the beginning of the experiment informing potential participants that no data will be collected.</li> </ol> <p>The <code>archive</code> and <code>pause-data</code> modes have complementary modes <code>unarchive</code> and <code>unpause-data</code> which respectively restore an archived experiment to the front end and resume data collection. The <code>delete</code> mode has no such complement, since it is permanent.</p> <p>Note</p> <p>You must run <code>prep</code> after <code>remove experiment</code> for the changes to your site to take effect.</p> <p>Syntax:</p> <pre><code>pushkin remove experiment &lt;options&gt;\n</code></pre> <p>or</p> <pre><code>pushkin rm exp &lt;options&gt;\n</code></pre> <p>Options:</p> <ul> <li> <p>experiments: <code>-e</code> or <code>--experiments</code> allows you to specify which experiment(s) to delete, archive, or unarchive. Provide the experiments' short names (i.e. the name of the folder in the <code>/experiments</code> directory) separated by spaces after the <code>-e</code> flag (e.g. <code>pushkin rm exp -e exp1 exp2 exp3</code>). If the <code>--experiments</code> option is omitted, the CLI will interactively prompt you to select the experiments you want.</p> </li> <li> <p>mode: <code>-m</code> or <code>--mode</code> allows you to specify the <code>delete</code>, <code>archive</code>, <code>unarchive</code>, <code>pause-data</code>, or <code>unpause-data</code> mode (e.g. <code>pushkin rm exp -m delete</code>). If the <code>--mode</code> option is omitted, the CLI will interactively prompt you to select which mode you want.</p> </li> <li> <p>force: <code>-f</code> or <code>--force</code> applies only to the <code>delete</code> mode and allows you to suppress the deletion confirmation prompt.</p> </li> <li> <p>verbose: <code>-v</code> or <code>--verbose</code> shows additional console output during the removal process which may be helpful for debugging.</p> </li> <li> <p>help: <code>-h</code> or <code>--help</code> displays the command's help information.</p> </li> </ul> <p>Details:</p> <p>All that results from calling <code>remove experiment</code> in the <code>archive</code> or <code>pause-data</code> mode (as well as their opposite modes) is that the experiment's <code>config.yaml</code> file will be updated with respect to the boolean property <code>archived</code> or <code>dataPaused</code>. You can change this property manually if you wish, but using <code>pushkin rm exp -m archive</code> or <code>pushkin rm exp -m pause-data</code> offers a convenient way to quickly change this property for multiple experiments.</p>"},{"location":"packages/pushkin-cli/#updatedb","title":"updateDB","text":"<p>Runs migrations and seeds for experiments to update the database. This is set up to ensure experiments using the same database (as defined in <code>pushkin.yaml</code>) are migrated at the same time to avoid errors with the <code>knex_migrations</code> table. This is automatically run as part of <code>pushkin prep</code>.</p> <p>Syntax:</p> <pre><code>pushkin updateDB\n</code></pre>"},{"location":"packages/pushkin-cli/#prep","title":"prep","text":"<p>Run inside a Pushkin project to prepare Pushkin to be run for local testing. Packages generated by yarn inside each experiment\u2019s web page and api controllers directories are moved to the core Pushkin code, installed there, and linked to the core code. Previous modules are uninstalled and removed.</p> <p>Syntax:</p> <p><pre><code>pushkin prep &lt;options&gt;\n</code></pre> Options:</p> <ul> <li> <p>no-migrations: <code>--no-migrations</code> will run <code>prep</code> without database migrations. If you do this, make sure the database structure has not changed since you ran <code>prep</code> previously (with migrations).</p> </li> <li> <p>verbose: <code>-v</code> or <code>--verbose</code> shows additional console output which may be helpful for debugging.</p> </li> <li> <p>help: <code>-h</code> or <code>--help</code> displays the command's help information.</p> </li> </ul> <p>Details:</p> <p>The code for <code>prep</code> is a bit convoluted (sorry). It loops through each experiment in the experiments folder (as defined by <code>pushkin.yaml</code>). For each experiment, it does the following:</p> <ul> <li>builds and locally publishes the experiment's api controllers and web page components. These are then added to the site's core API and front-end packages, respectively.</li> <li>compiles the experiment's worker and then builds a Docker image for it. It is then added to <code>docker-compose.dev.yml</code> so that docker knows to include it when the website is built.</li> <li>updates <code>pushkin/front-end/src/experiments.js</code> to list the experiment, along with key information from its config file. This will be read by the front end to build the list of experiments to display to potential participants.</li> </ul> <p>Additionally, <code>prep</code> builds the other docker images for remaining components of the Pushkin site, including the main database, the transactions database, the API, and the front end.</p>"},{"location":"packages/pushkin-cli/#start","title":"start","text":"<p>Starts the local deploy of your Pushkin site for debugging purposes.</p> <p>Syntax:</p> <pre><code>pushkin start &lt;options&gt;\n</code></pre> <p>Options:</p> <ul> <li> <p>no-cache: <code>--no-cache</code> will rebuild all Docker images from scratch without using the cache. By default, this is false.</p> </li> <li> <p>verbose: <code>-v</code> or <code>--verbose</code> shows additional console output which may be helpful for debugging.</p> </li> <li> <p>help: <code>-h</code> or <code>--help</code> displays the command's help information.</p> </li> </ul>"},{"location":"packages/pushkin-cli/#stop","title":"stop","text":"<p>Stops the local deploy. This will not remove the local Docker images. To do that, see <code>pushkin kill</code> and <code>pushkin armageddon</code>.</p> <p>Syntax:</p> <pre><code>pushkin stop\n</code></pre>"},{"location":"packages/pushkin-cli/#kill","title":"kill","text":"<p>Removes all containers and volumes from local Docker, as well as pushkin-specific images. Sometimes, if you're having issues developing or seeing updates to your Pushkin project, it may be helpful to run this command to ensure docker isn't holding any problematic code or issues in containers.</p> <p>Syntax:</p> <pre><code>pushkin kill\n</code></pre>"},{"location":"packages/pushkin-cli/#armageddon","title":"armageddon","text":"<p>Performs a complete reset of local Docker, including containers, volumes, and third-party images. Sometimes, if you're having issues developing or seeing updates to your Pushkin project, it may be helpful to run this command to ensure docker isn't holding any problematic code or issues in containers/images. This may generate some error messages, which you can safely ignore.</p> <p>Syntax:</p> <pre><code>pushkin armageddon\n</code></pre>"},{"location":"packages/pushkin-cli/#help","title":"help","text":"<p>Provides help information for <code>pushkin</code> commands.</p> <p>Syntax:</p> <pre><code>pushkin help &lt;command&gt;\n</code></pre> <p>Arguments:</p> <ul> <li> <p>command: string</p> <p>Add the command after <code>help</code> (e.g. <code>pushkin help prep</code> to learn about the <code>prep</code> command and its options). Defaults to a list of all commands and general information about each if no command is specified.</p> </li> </ul>"},{"location":"packages/pushkin-client/","title":"pushkin-client","text":"<p>The Pushkin client is available on NPM under <code>pushkin-client</code>. It should be instantiated once imported into a web page (see <code>/experiments/&lt;experiment_name&gt;/web page/src/index.js</code>):</p> <pre><code>import pushkinClient from \"pushkin-client\";\nconst pushkin = new pushkinClient();\n</code></pre> <p>The module has the following methods:</p>"},{"location":"packages/pushkin-client/#connect","title":"connect","text":"<p>Arguments:</p> <ul> <li>API URL: string</li> </ul> <p>Location of this experiment\u2019s API endpoint.</p> <p>Returns: Promise. Resolves on successful connection.</p>"},{"location":"packages/pushkin-client/#loadscript","title":"loadScript","text":"<p>Arguments:</p> <ul> <li>URL: string</li> </ul> <p>URL of a script to load.</p> <p>Returns: Promise. Resolves upon successfully loading the script.</p> <p>Scripts are reloaded if already present in the DOM, making sure they run again if a page changes.</p>"},{"location":"packages/pushkin-client/#loadscripts","title":"loadScripts","text":"<p>Arguments:</p> <ul> <li>URLs: string array</li> </ul> <p>URLs to load.</p> <p>Returns: Promise. Resolves upon successfully loading all scripts.</p> <p>A convenience function. Uses <code>loadScript</code> and <code>Promise.all</code> on the backend.</p>"},{"location":"packages/pushkin-client/#prepexperimentrun","title":"prepExperimentRun","text":"<p>Arguments: None</p> <p>Returns: Promise. Resolves upon affirmation.</p> <p>Sends a POST request to <code>&lt;exp_api&gt;/startExperiment</code> to allow the backend to prepare stimuli for the experiment, if need be. Depends on defaults being enabled in the experiment\u2019s API and worker.</p>"},{"location":"packages/pushkin-client/#getallstimuli","title":"getAllStimuli","text":"<p>Arguments: None</p> <p>Returns: Promise. Resolves to an array of jsPsych stimuli.</p> <p>Obtains the stimuli for this experiment in one request. Depends on defaults being enabled in the experiment\u2019s API and worker.</p>"},{"location":"packages/pushkin-client/#savestimulusresponse","title":"saveStimulusResponse","text":"<p>Arguments:</p> <ul> <li>jsPych data object: { user_id : int, \u2026 }</li> </ul> <p>Data to be saved in the database under <code>user_id</code>. Posted to <code>&lt;exp_api&gt;/stimulusResponse</code>.</p> <p>Returns: Promise. Resolves upon successful database save.</p> <p>The function <code>setSaveAfterEachStimulus</code> is now deprecated, so <code>saveStimulusResponse</code> is called at the <code>on_data_update</code> event which happens at the end of every jsPsych trial after the <code>on_finish</code> (trial) and <code>on_trial_finish</code> events. The function is added as a parameter when initializing jsPsych in <code>experiments/&lt;experiment_name&gt;/web page/src/index.js</code> like so:</p> <pre><code>const jsPsych = initJsPsych({\n  ...,\n  on_data_update: (data) =&gt; pushkin.saveStimulusResponse(data),\n});\n</code></pre>"},{"location":"packages/pushkin-client/#insertmetaresponse","title":"insertMetaResponse","text":"<p>Arguments:</p> <ul> <li>jsPych data object: { user_id : int, \u2026 }</li> </ul> <p>Returns: Promise. Resolves on successful connection.</p>"},{"location":"packages/pushkin-client/#endexperiment","title":"endExperiment","text":"<p>Arguments: None</p> <p>Returns: Promise. Resolves upon successfully notifying the worker.</p> <p>Notify the worker that the experiment has ended and that it can stop preparing for future stimuli. This should probably be called whenever the user leaves a page in the middle of an experiment as well.</p>"},{"location":"packages/pushkin-client/#customapicall","title":"customApiCall","text":"<p>Arguments:</p> <ul> <li>path: string</li> </ul> <p>URL of API endpoint to send this call to.</p> <ul> <li>data: object</li> </ul> <p>Data to send to the API endpoint.</p> <ul> <li>httpMethod: string (optional)</li> </ul> <p>A lowercase string of an HTTP method to call the endpoint, such as \u201cget\u201d or \u201cput\u201d.</p> <p>Returns: Promise. Resolves with response data.</p> <p>Simplifies calls to custom API endpoints.</p>"},{"location":"packages/pushkin-worker/","title":"pushkin-worker","text":"<p>Coming soon! Please raise any questions in our GitHub discussions page.</p>"},{"location":"site-templates/site-basic/","title":"@pushkin-templates/site-basic","text":"<p>The basic template provides everything you need for building a bare-bones Pushkin site. It does not include authentication, forum, or dashboard features.</p>"},{"location":"site-templates/site-basic/#installing-the-exp-basic-template","title":"Installing the exp-basic template","text":"<p>Make sure you've first created a new directory in which you'll build your Pushkin site. From within your new site directory, run:</p> <pre><code>pushkin i site\n</code></pre> <p>Select the main Pushkin distribution and <code>@pushkin-templates/site-basic</code> from the list of available templates. Then choose which version you want (the latest is typically recommended).</p>"},{"location":"site-templates/site-templates-overview/","title":"Overview of site templates","text":"<p>Pushkin uses site templates to set up the core functionality of the user's site \u2014 essentially, everything except the experiments themselves. Site templates are distributed as npm packages, which get added to the user's site as dependencies when they run <code>pushkin install site</code>. The template files are then unzipped into the user's site directory and subsequently manipulated by the CLI.</p> How can I work on multiple Pushkin sites simultaneously? <p>When running Pushkin on your local system, you can only work on a single Pushkin site at a time. For most users, this shouldn't present a problem, since additional experiments can always be added to a site; however, if you do need to work on multiple sites simultaneously, using GitHub Codespaces will allow you to keep your sites in separate virtual environments.</p>"},{"location":"site-templates/site-templates-overview/#currently-available-site-templates","title":"Currently available site templates","text":"<p>Note</p> <p>The only site template currently available from the main Pushkin distribution is the basic template. The Pushkin development team plans to produce additional templates in the future.</p> <ul> <li>site-basic: The basic template provides everything you need for building a bare-bones Pushkin site. It does not include authentication, forum, or dashboard features.</li> </ul>"},{"location":"site-templates/site-templates-overview/#how-to-install-a-site-template","title":"How to install a site template","text":"<p>Create a new directory for your Pushkin site. Navigate into this folder and run:</p> <pre><code>pushkin install site\n</code></pre> <p>or</p> <pre><code>pushkin i site\n</code></pre> <p>Follow the CLI's prompts to select the template you want to install. In addition to templates from the main distribution, the CLI also offers you the ability to install templates from:</p> <ul> <li>path: This option allows you to install a site template from a local path. In this case, the template must still be implemented as a package and will automatically be locally published using <code>yalc</code>. Use this option if you are developing a new site template or testing a development version of an existing one.</li> <li>npm: The CLI can attempt to install a site template from an arbitrary npm package, although obviously this will fail if the package isn't properly set up as a Pushkin site template. This option might be appropriate for you if you need to distribute a template you've developed (perhaps as private package) but don't wish to add it to the main Pushkin distribution. Generally, however, we encourage contributions of new templates that might be of use to the the broader Pushkin community (see our contributor guidelines and below for specific notes on contributing site templates).</li> </ul>"},{"location":"site-templates/site-templates-overview/#contributing-site-templates","title":"Contributing site templates","text":"<p>There is currently no way of automatically packaging up an existing custom site into a new site template. How complicated the process will be of turning your site into a template depends on how much customization you've done (presumably based on the basic template). Complex customizations may present unexpected challenges for creation of a template. We encourage potential template contributors to reach out to the Pushkin team if they encounter any such issues.</p> <p>In general, we encourage you to follow to the contributor guidelines. Additionally, if you'd like to contribute a template, please consider how you can make it maximally general by parameterizing as many of your customizations as you can. Try to imagine what variations on your site would be relevant for other researchers and make it easy to implement those variations via changing configuration settings.</p>"},{"location":"site-templates/site-templates-overview/#customizing-sites","title":"Customizing sites","text":""},{"location":"site-templates/site-templates-overview/#about-page","title":"About Page","text":"<p>The About page is wrapped in a fluid <code>Container</code> component, which is a full-width container, spanning the entire width of the viewport.</p>"},{"location":"site-templates/site-templates-overview/#card-image-overlays","title":"Card Image Overlays","text":"<p>The <code>&lt;Card.ImgOverlay&gt;</code> component turns an image into a card background and overlays your card\u2019s text:</p> <pre><code>&lt;Card className=\"bg-dark text-white\"&gt;\n  &lt;Card.Img src={require(\"../assets/images/aboutPage/AboutUs.jpeg\")} /&gt;\n  &lt;Card.ImgOverlay&gt;\n    &lt;Card.Title as=\"h1\" style={{marginTop:'12rem'}}&gt;\n      Who We Are\n    &lt;/Card.Title&gt;\n    &lt;Card.Text as=\"h4\" className=\"m-5\"&gt;\n      We do citizen science to learn how the the mind works.\n    &lt;/Card.Text&gt;\n    &lt;Card.Text as=\"h4\"&gt;\n      We are awesome scientists!\n    &lt;/Card.Text&gt;\n  &lt;/Card.ImgOverlay&gt;\n&lt;/Card&gt;\n</code></pre>"},{"location":"site-templates/site-templates-overview/#add-a-team-member-in-about-page","title":"Add a Team Member In About Page","text":"<p>To add a team member to the About page, open <code>People.js</code> located in <code>components/TeamMember</code>, it should be an array of objects that look like this:</p> <pre><code>const people = [\n  {\n    name: 'Team Member Name',\n    image: 'Template.png',\n    description: 'Enter team member description here.'\n  },\n  {\n    name: 'Team Member Name',\n    image: 'Template.png',\n    description: 'Enter team member description here.'\n  },\n  {\n    name: 'Team Member Name',\n    image: 'Template.png',\n    description: 'Enter team member description here.'\n  },\n]\n</code></pre> <p>Each object contains three properties: name, image, and description. Edit the name and description properties in <code>People.js</code>.</p> <p>To add a profile picture of the team member. Copy the image file into the <code>assets/images/teamMember</code> folder.</p> <p>Then edit the image property in <code>People.js</code>, making sure the name of the image file and the image property here match, including the extension name, like: <code>bob.jpg</code>.</p>"},{"location":"site-templates/site-templates-overview/#feedback-page","title":"Feedback Page","text":"<p>You can go to the feedback page by clicking the <code>HERE</code> button of  jumbotron in the home page or clicking the <code>Leave Feedback</code> button in the footer.</p> <p>To embed a Google form into the feedback page:</p> <ol> <li>Create your own google form</li> <li>Go to \u201cForm\u201d dropdown in the spreadsheet view, and click \u201cEmbed form in a webpage\u201d.</li> <li>This will give you an <code>&lt;iframe&gt;</code> snippet to place on the site template.</li> <li>Change the <code>src</code> attribute in <code>&lt;iframe&gt;</code> to your Google form link, it is located in <code>pushkin/front-end/src/pages/Feedback.js</code></li> </ol>"},{"location":"site-templates/site-templates-overview/#findings-page","title":"Findings Page","text":""},{"location":"site-templates/site-templates-overview/#add-a-findings-card","title":"Add a Findings Card","text":"<p>To add a card to the findings page, open <code>FindingsData.js</code> located in <code>components/Findings</code>. You should see an array of objects that looks like this:</p> <pre><code>const findingsData = [\n  {\n    id: 1,\n    title: 'Finding 1',\n    image: 'stock1.jpeg',\n    description:\n      'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. A scelerisque purus semper eget duis at tellus at. Ultrices sagittis orci a scelerisque purus. Aliquet eget sit amet tellus cras adipiscing enim. Lorem dolor sed viverra ipsum nunc aliquet. Sagittis orci a scelerisque purus semper. Pulvinar etiam non quam lacus suspendisse faucibus. Id porta nibh venenatis cras sed felis eget. Vitae sapien pellentesque habitant morbi tristique. Platea dictumst quisque sagittis purus sit amet volutpat. Pharetra et ultrices neque ornare aenean euismod elementum nisi quis. Nulla aliquet enim tortor at auctor urna nunc id cursus. Curabitur gravida arcu ac tortor dignissim.Habitasse platea dictumst quisque sagittis purus sit amet. Porttitor leo a diam sollicitudin tempor id eu nisl. Aenean vel elit scelerisque mauris pellentesque pulvinar pellentesque habitant. Varius duis at consectetur lorem donec massa. Molestie nunc non blandit massa enim nec dui.',\n    link: true,\n    url: 'https://www.google.com/'\n  },\n  {\n    id: 2,\n    title: 'Finding 2',\n    image: 'stock2.jpeg',\n    description:\n      'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. A scelerisque purus semper eget duis at tellus at. Ultrices sagittis orci a scelerisque purus. Aliquet eget sit amet tellus cras adipiscing enim. Lorem dolor sed viverra ipsum nunc aliquet. Sagittis orci a scelerisque purus semper. Pulvinar etiam non quam lacus suspendisse faucibus. Id porta nibh venenatis cras sed felis eget. Vitae sapien pellentesque habitant morbi tristique. Platea dictumst quisque sagittis purus sit amet volutpat. Pharetra et ultrices neque ornare aenean euismod elementum nisi quis. Nulla aliquet enim tortor at auctor urna nunc id cursus. Curabitur gravida arcu ac tortor dignissim.Habitasse platea dictumst quisque sagittis purus sit amet. Porttitor leo a diam sollicitudin tempor id eu nisl. Aenean vel elit scelerisque mauris pellentesque pulvinar pellentesque habitant. Varius duis at consectetur lorem donec massa. Molestie nunc non blandit massa enim nec dui.',\n    link: false,\n    url: ''\n  },\n  {\n    id: 3,\n    title: 'Finding 3',\n    image: 'stock3.jpeg',\n    description:\n      'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. A scelerisque purus semper eget duis at tellus at. Ultrices sagittis orci a scelerisque purus. Aliquet eget sit amet tellus cras adipiscing enim. Lorem dolor sed viverra ipsum nunc aliquet. Sagittis orci a scelerisque purus semper. Pulvinar etiam non quam lacus suspendisse faucibus. Id porta nibh venenatis cras sed felis eget. Vitae sapien pellentesque habitant morbi tristique. Platea dictumst quisque sagittis purus sit amet volutpat. Pharetra et ultrices neque ornare aenean euismod elementum nisi quis. Nulla aliquet enim tortor at auctor urna nunc id cursus. Curabitur gravida arcu ac tortor dignissim.Habitasse platea dictumst quisque sagittis purus sit amet. Porttitor leo a diam sollicitudin tempor id eu nisl. Aenean vel elit scelerisque mauris pellentesque pulvinar pellentesque habitant. Varius duis at consectetur lorem donec massa. Molestie nunc non blandit massa enim nec dui.',\n    link: false,\n    url: ''\n  }\n];\n</code></pre> <p>You can edit five of the properties: title, image, description, link, and url in each object, in order to change the content in each findings card. You can add more by copying and pasting from { through }, making sure that you have a comma after } any time there is another { following.</p> <p>To add an external link, set link property to <code>true</code> and fill the url property. Then a Read More button will appear on the findings card.</p>"},{"location":"site-templates/site-templates-overview/#cardgroup","title":"CardGroup","text":"<p>The <code>&lt;CardGroup&gt;</code> component renders cards as a single, attached element with equal width and height columns. We wrapped card components in <code>&lt;CardGroup&gt;</code> inside a <code>&lt;Container&gt;</code> in the findings page.</p>"},{"location":"site-templates/site-templates-overview/#align-card-vertically-in-cardgroup","title":"Align Card Vertically in CardGroup","text":"<p>Use two <code>&lt;Col&gt;</code> components wrapped in one <code>&lt;Row&gt;</code> inside cards:</p> <pre><code>&lt;Card&gt;\n  &lt;Row&gt;\n    &lt;Col&gt;\n      ...\n    &lt;/Col&gt;\n    &lt;Col&gt;\n      ...\n    &lt;/Col&gt;\n  &lt;/Row&gt;\n&lt;/Card&gt;\n</code></pre> <p>The content in the first <code>&lt;Col&gt;</code> will be on the left side of the card. And the content in the second <code>&lt;Col&gt;</code> will be on the right side of the card.</p> <p>For example, the first card in the findings page has its <code>&lt;Card.Img&gt;</code> in the first <code>&lt;Col&gt;</code>, <code>&lt;Card.Body&gt;</code>, <code>&lt;Card.Title&gt;</code>, <code>&lt;Card.Text&gt;</code> in the second <code>&lt;Col&gt;</code></p>"},{"location":"site-templates/site-templates-overview/#header-and-footer","title":"Header and Footer","text":"<p>The <code>Header.js</code> and <code>Footer.js</code> components are located in <code>pushkin/front-end/src/components/Layout</code></p>"},{"location":"site-templates/site-templates-overview/#navbar-logo","title":"Navbar logo","text":"<p>To Change the logo in the navbar, copy your logo image into the <code>pushkin/front-end/src/assets/logo</code> folder, modify the path in <code>src={require(\"../../assets/images/logo/NavbarLogo.png\")}</code> in the <code>&lt;Navbar.Brand&gt;</code>. You can also modify the logo\u2019s size using the <code>width</code> and <code>height</code> attributes in the <code>&lt;img /&gt;</code> tag.</p>"},{"location":"site-templates/site-templates-overview/#navbar-color-schemes","title":"Navbar Color Schemes","text":"<p>Choose from <code>variant=\"light\"</code> for use with light background colors, <code>variant=\"dark\"</code> for dark background colors. Then, customize with the <code>bg</code> prop or any custom css! You can also use the <code>className</code> prop in the <code>&lt;Navbar&gt;</code> component, like <code>className=\"navbar-dark bg-dark\"</code></p>"},{"location":"site-templates/site-templates-overview/#footer","title":"Footer","text":"<p>The footer is wrapped in <code>&lt;Row&gt;</code> component. You can change the background color in the style prop: <code>style={{backgroundColor:'#eeeeee'}}</code>.</p>"},{"location":"site-templates/site-templates-overview/#home-page","title":"Home Page","text":""},{"location":"site-templates/site-templates-overview/#add-a-quiz","title":"Add a Quiz","text":"<p>To add a quiz, run <code>pushkin install experiment</code>. Select the experiment template of your choice. This will create a pushkin experiment in the <code>experiments/</code> folder.</p> <p>Open the <code>config.js</code> located in your experiment folder, and modify the experiment name, shortName, logo, text, etc.</p> <pre><code>experimentName: &amp;fullName 'mind Experiment'\nshortName: &amp;shortName 'mind' # This should be unique as its used for urls, etc.\napiControllers: # The default export from each of these locations will be attached to a pushkin API\n  - mountPath: *shortName\n    location: 'api controllers'\n    name: 'mycontroller'\nworker:\n  location: 'worker'\n  service: # what to add as a service in main compose file\n    image: *shortName\n    links:\n      - message-queue\n      - test_db\n    environment:\n      - \"AMQP_ADDRESS=amqp://message-queue:5672\"\n      - \"DB_USER=postgres\"\n      - \"DB_PASS=\"\n      - \"DB_URL=test_db\"\n      - \"DB_NAME=test_db\"\nwebPage:\n  location: 'web page'\nmigrations:\n  location: 'migrations'\nseeds:\n  location: ''\n# Used for migration and seed commands via main CLI\n# Note that these might be different than those given to the worker,\n# Since it's running inside a linked docker container\ndatabase: 'localtestdb'\nlogo: 'Mind.png'\ntext: 'Enter your experiment description here'\ntagline: 'Be a citizen scientist! Try this quiz.'\nduration: ''\n</code></pre> <p>After running <code>pushkin prep</code>, the <code>experiments.js</code> located in <code>pushkin/front-end/src</code> will be updated, it should be an array of objects like this:</p> <pre><code>export default [\n  { fullName: 'vocab Experiment', shortName: 'vocab', module: pushkinComponent7e170301859545dab691a08652b798a8, logo: 'logo512.png', tagline: 'Be a citizen scientist! Try this quiz.', duration: '' },\n  { fullName: 'mind Experiment', shortName: 'mind', module: pushkinComponent1d77ca65c9f94dac834629611d452c8e, logo: 'logo512.png', tagline: 'Be a citizen scientist! Try this quiz.', duration: '' },\n  { fullName: 'whichenglish Experiment', shortName: 'whichenglish', module: pushkinComponentbbca5356917345c2b2532e84e5325197, logo: 'logo512.png', tagline: 'Be a citizen scientist! Try this quiz.', duration: '' },\n];\n</code></pre> <p>Then the new quiz card will be automatically added to the home page.</p>"},{"location":"site-templates/site-templates-overview/#jumbotron","title":"Jumbotron","text":"<p>The Jumbotron is a lightweight, flexible component that can optionally extend the entire viewport to showcase key content on your site.</p> <pre><code>&lt;Jumbotron style={{backgroundColor:'#eeeeee'}}&gt;\n  &lt;div&gt;\n    We do &lt;strong&gt;citizen science&lt;/strong&gt; to learn how the mind\n    works.{' '}\n  &lt;/div&gt;\n  &lt;div&gt;\n    &lt;strong&gt;\n      Pick a game to get started!\n    &lt;/strong&gt;\n  &lt;/div&gt;\n  &lt;div className=\"mt-3\"&gt;\n    Feel free to send us feedback &lt;LinkContainer to=\"/feedback\"&gt;&lt;a&gt;&lt;strong&gt;HERE&lt;/strong&gt;&lt;/a&gt;&lt;/LinkContainer&gt;\n  &lt;/div&gt;\n&lt;/Jumbotron&gt;\n</code></pre> <p>It includes a link to the feedback page and an anchor tag wrapped in <code>&lt;LinkContainer&gt;</code> component.</p>"},{"location":"site-templates/site-templates-overview/#carddeck","title":"CardDeck","text":"<p>The <code>&lt;CardDeck&gt;</code> creates a grid of cards that are of equal height and width. The layout will automatically adjust as you insert more cards. We recommend putting every 3 cards in a card deck. Quizzes are wrapped in card decks in <code>Home.js</code> located in <code>pushkin/front-end/src/pages</code>.</p>"},{"location":"site-templates/site-templates-overview/#card","title":"Card","text":"<p>Bootstrap\u2019s cards provides a flexible and extensible content container with multiple variants and options:</p> <ul> <li>Body: Use <code>&lt;Card.Body&gt;</code> to pad content inside a <code>&lt;Card&gt;</code>.</li> <li>Title, text, and links: Using <code>&lt;Card.Title&gt;</code>, <code>&lt;Card.Subtitle&gt;</code>, and <code>&lt;Card.Text&gt;</code> inside the <code>&lt;Card.Body&gt;</code> will line them up nicely. <code>&lt;Card.Link&gt;</code> are used to line up links next to each other.</li> <li>Images: Cards include a few options for working with images. Choose from appending \u201cimage caps\u201d at either end of a card, overlaying images with card content, or simply embedding the image in a card.</li> <li>Image clickable area styling: If you would like to use circular images and limit the clickable space to be circular, be sure to keep the <code>:hoverStyles.circleStyle</code> className in the <code>&lt;LinkContainer</code>. If you would like to use square or rectangular images, be sure to not include this className.</li> </ul> <p>For example, the quiz card in the home page:</p> <pre><code>&lt;Card className=\"border-0 shadow\" style={styles.card}&gt;\n  &lt;Card.Body&gt;\n    &lt;LinkContainer\n      // style={styles.cardButton}\n      to={'/quizzes/' + this.props.id}\n      className={css(hoverStyles.opacityStyle, hoverStyles.circleStyle)}\n    &gt;\n      &lt;Card.Img src={this.props.img} style={styles.cardImage} /&gt;\n    &lt;/LinkContainer&gt;\n    &lt;Card.Title className=\"mt-4\" style={styles.cardTitle}&gt;\n      {this.props.title}\n    &lt;/Card.Title&gt;\n    &lt;Card.Text className=\"mt-4\" style={styles.cardText}&gt;\n      {this.props.text}\n\n      {/* {this.props.duration &amp;&amp; (\n        &lt;p&gt;\n          {' '}\n          &lt;strong&gt;\n            {' '}\n            Average time: {this.props.duration} minutes.{' '}\n          &lt;/strong&gt;{' '}\n        &lt;/p&gt;\n      )}\n\n      {this.state.count &amp;&amp; (\n        &lt;p&gt; {this.state.count} players so far! &lt;/p&gt;\n      )} */}\n    &lt;/Card.Text&gt;\n  &lt;/Card.Body&gt;\n  &lt;Row className=\"justify-content-center mt-2\"&gt;\n    &lt;LinkContainer\n      // style={styles.cardButton}\n      to={'/quizzes/' + this.props.id}\n    &gt;\n      &lt;Button className={css(hoverStyles.cardButton)}&gt;Play Now&lt;/Button&gt;\n    &lt;/LinkContainer&gt;\n  &lt;/Row&gt;\n  &lt;Row className=\"justify-content-center mt-3 mb-3\"&gt;\n    &lt;i.SocialIcon\n      url={share.facebook}\n      onClick={e =&gt; {\n        e.preventDefault();\n        share.open(share.facebook);\n      }}\n      className={css(hoverStyles.socialIcon, hoverStyles.opacityStyle)}\n      target=\"_blank\"\n    /&gt;\n    &lt;i.SocialIcon\n      url={share.twitter}\n      onClick={e =&gt; {\n        e.preventDefault();\n        share.open(share.twitter);\n      }}\n      className={css(hoverStyles.socialIcon, hoverStyles.opacityStyle)}\n      target=\"_blank\"\n    /&gt;\n    &lt;i.SocialIcon\n      url={share.email}\n      className={css(hoverStyles.socialIcon, hoverStyles.opacityStyle)}\n      target=\"_blank\"\n    /&gt;\n    {/* BETA ribbon */}\n    {/* {this.props.beta &amp;&amp; (\n      &lt;LinkContainer to={'/quizzes/' + this.props.id}&gt;\n        &lt;div className={s.ribbon + ' ' + s.ribbonBottomLeft}&gt;\n          {' '}\n          &lt;span&gt;BETA&lt;/span&gt;{' '}\n        &lt;/div&gt;\n      &lt;/LinkContainer&gt;\n    )} */}\n  &lt;/Row&gt;\n&lt;/Card&gt;\n</code></pre> <p>The components inside a quiz card, in order from top to bottom, are:</p> <ul> <li><code>&lt;Card.Img&gt;</code>: Quiz cover image</li> <li><code>&lt;Card.Title&gt;</code>: Quiz name</li> <li><code>&lt;Card.Text&gt;</code>: Quiz description</li> <li><code>&lt;Button&gt;</code>: Wrapped in <code>&lt;LinkContainer&gt;</code></li> <li><code>&lt;SocialIcon&gt;</code>: The react social icons provides a set of beautiful svg social icons.</li> </ul>"},{"location":"site-templates/site-templates-overview/#react-bootstrap","title":"React Bootstrap","text":"<p>The pushkin site template uses React-Bootstrap as its front-end UI library. It is a complete re-implementation of the Bootstrap components using React. It has no dependency on either bootstrap.js or jQuery.</p>"},{"location":"site-templates/site-templates-overview/#import-libraries","title":"Import Libraries","text":"<p>You should import individual components like: <code>react-bootstrap/Button</code> rather than the entire library. Doing so pulls in only the specific components that you use, which can significantly reduce the amount of code you end up sending to the client:</p> <pre><code>import Button from 'react-bootstrap/Button';\n\n// or less ideally\nimport { Button } from 'react-bootstrap';\n</code></pre>"},{"location":"site-templates/site-templates-overview/#inline-styling","title":"Inline Styling","text":"<p>In React, inline styles are not specified as a string. Instead, they are specified with an object whose key is the camelCased version of the style name, and whose value is the style\u2019s value, usually a string:</p> <pre><code>const styles = {\n  card: {\n    backgroundColor: '#B7E0F2',\n    borderRadius: 55\n  },\n  cardTitle: {\n    fontSize: 26,\n    fontWeight: 600\n  },\n  cardBody: {\n    padding: '2.5rem'\n  },\n  cardImage: {\n    width: '100%',\n    height: '15vw',\n    objectFit: 'cover',\n    borderRadius: 55\n  }\n}\n</code></pre> <p>React lets you add CSS inline, written as attributes and passed to elements:</p> <pre><code>&lt;Container className=\"p-0\" fluid style={styles.container}&gt;\n</code></pre>"},{"location":"site-templates/site-templates-overview/#spacing","title":"Spacing","text":"<p>React Bootstrap spacing is a utility that assigns responsive margin or padding classes to elements to modify their display position.</p> <p>The classes are named using the format {property}{sides}-{size} for xs and {property}{sides}-{breakpoint}-{size} for sm, md, lg, and xl.</p> <p>Where property is one of:</p> <ul> <li>m - for classes that set margin</li> <li>p - for classes that set padding</li> </ul> <p>Where sides is one of:</p> <ul> <li>t - for classes that set margin-top or padding-top</li> <li>b - for classes that set margin-bottom or padding-bottom</li> <li>l - for classes that set margin-left or padding-left</li> <li>r - for classes that set margin-right or padding-right</li> <li>x - for classes that set both *-left and *-right</li> <li>y - for classes that set both *-top and *-bottom</li> <li>blank - for classes that set a margin or padding on all 4 sides of the element</li> </ul> <p>Where breakpoint is one of:</p> <ul> <li>sm</li> <li>md</li> <li>lg</li> <li>xl</li> </ul> <p>Where size is one of:</p> <ul> <li>0 - for classes that eliminate the margin or padding by setting it to 0</li> <li>1</li> <li>2</li> <li>3</li> <li>4</li> <li>5</li> </ul> <p>For example:</p> <pre><code>&lt;img className=\"ml-2 mr-2\" /&gt;\n</code></pre> <p>It means <code>marginLeft</code> is 2 and <code>marginRight</code> is 2 as well.</p> <pre><code>&lt;img className=\"m-4\" /&gt;\n</code></pre> <p>It means margins of all sides (left, right, top, bottom) are 4.</p>"},{"location":"site-templates/site-templates-overview/#linkcontainer","title":"LinkContainer","text":"<p><code>&lt;LinkContainer&gt;</code> is a component of react-router-bootstrap. Wrap your React Bootstrap element in a <code>&lt;LinkContainer&gt;</code> to make it behave like a React Router <code>&lt;Link&gt;</code> <code>&lt;LinkContainer&gt;</code> accepts same parameters as React Router\u2019s <code>&lt;NavLink&gt;</code></p>"},{"location":"support/github-discussions/","title":"GitHub Discussions","text":"<p>The Pushkin team uses GitHub Discussions as our primary interface with Pushkin users. Please start a discussion there if you'd like to ask a question, report a potential bug, or request a new feature. For bug reports and feature requests, a Pushkin team member can determine whether to elevate a discussion into a new issue (linking back to the original discussion). In some cases, advanced users may immediately recognize that a bug merits a new issue, but generally starting with a discussion is a best practice.</p> <p>Please keep the following in mind when posting in discussions:</p> <ul> <li>Search for related discussions and issues first before creating a new thread. Even if you need to create a new thread, linking back to related discussions may help others.</li> <li>When relevant, include code snippets and CLI output. Typically, copying and pasting the error text rather than screenshotting will be most helpful, but sometimes screenshots will be useful for front-end issues.</li> <li>If you're asking for help with an error, include relevant version numbers. For most errors, versions of pushkin-cli, experiment/site templates, Docker Engine, and Node.js will be useful information. In some cases, it may also be helpful to include the version numbers of other components, e.g. pushkin-api, pushkin-client, pushkin-worker, yarn, jsPsych plugins, etc.</li> <li>If you encounter a problem with one of your experiments, try to determine whether it pertains to the interaction between Pushkin and jsPsych, rather than jsPsych itself. The best place for questions about jsPsych itself is jsPsych\u2019s discussions page. A good workflow for developing Pushkin experiments is to first create a working example as a plain jsPsych experiment. If your experiment doesn\u2019t do what you expect in plain jsPsych, your issue isn\u2019t with Pushkin.</li> </ul>"},{"location":"support/troubleshooting/","title":"Troubleshooting Pushkin","text":"<p>Below you'll find a list of potential error messages you might encounter while running Pushkin and how to fix them. If you have any problems not listed here, check out our GitHub Discussions to see if others have had the same problem or report the problem to our team.</p>"},{"location":"support/troubleshooting/#error-connection-error","title":"error: connection error","text":"<p>Make sure you are logged into your docker by running the following command: <code>docker login</code></p>"},{"location":"support/troubleshooting/#error-database-test_db-does-not-exist","title":"error: database \"test_db\" does not exist","text":"<p>In cases where your database does not successfully get set up, it's possible that Postgres is clogging port 5432 on your computer. To check if this is the case run the following in Terminal/your command line: <code>sudo lsof -i tcp:5432</code></p> <p>If Postgres is running on port 5432, run the following to clear it: <code>sudo pkill -u postgres</code></p>"},{"location":"support/troubleshooting/#cannot-start-service-server-ports-are-not-available-listen-tcp-000080-bind-address-already-in-use","title":"Cannot start service server: Ports are not available: listen tcp 0.0.0.0:80: bind: address already in use","text":"<p>You must have Port 80 open to run your Pushkin site locally, so make sure you aren't running any other web servers there before running <code>pushkin prep</code>. If you encounter this error, you can find what is clogging your Port 80 using the command: <code>lsof -i tcp:80</code>. The output should look something like this:</p> <p>Then to clear the port, run the following (replacing <code>&lt;PID&gt;</code> with the PID(s) listed from the lsof command above): <code>kill -9 &lt;PID&gt;</code></p>"},{"location":"support/troubleshooting/#homebrew-install-not-working","title":"homebrew install not working","text":"<p>Homebrew is not compatible with some shells such as tcsh, try using bash or xsh instead.</p>"},{"location":"support/troubleshooting/#error-the-migration-directory-is-corrupt-in-pushkin-prep","title":"Error: The migration directory is corrupt in <code>pushkin prep</code>","text":"<p>This can happen when your database is still configured for another Pushkin site set up on your system. Pushkin does not currently support two active Pushkin sites at the same time, so if you would like to switch between Pushkin sites you're working on, you'll have to run <code>pushkin kill</code> before running <code>pushkin prep</code> and make sure that the docker images are cleaned out.</p>"},{"location":"support/troubleshooting/#error-no-space-left-on-device","title":"Error: no space left on device","text":"<p>If you are using Pushkin on an Amazon EC2 instance and have several experiments installed, you may run out of space on your instance. If you get an error stating that there is no space left on your device, you will need to increase the amount of disk space allocated to your instance in order to continue.</p> <p>At the time of writing, the AWS Free Tier includes 30 GB of Elastic Block storage\u2014the kind of storage your EC2 instance uses\u2014for the first 12 months of your AWS membership. Remember that deploying Pushkin to AWS also includes using some of that storage. Increasing from the default 8 GB of storage to 16 GB might be a good start.</p> <p>This tutorial explains how to increase the disk size of your EC2 instance.</p> <p>You can also try, regardless of the platform you are using, running the command <code>docker system prune</code> might solve the issue:</p> <p>Stackoverflow thread on docker system prune</p>"},{"location":"support/troubleshooting/#command-failed-docker-buildx-build","title":"Command failed: docker buildx build","text":"<p>If you have an older version of Docker, you might run into this error. The solution is to upgrade Docker: - Confirm that you have at least Docker Engine 23.0 and Docker Desktop 4.19.  - From the commandline, run <code>docker buildx create --name mybuilder --driver docker-container --bootstrap --use</code></p>"}]}